const cds = require ('../index'), { log } = cds.env

// Use configured logger in case of cds serve
if (log.Logger || log.service) {
  if (log.Logger) exports.Logger = require (log.Logger)
  if (log.service) {
    const {app} = cds, srv = require('./service')
    app ? setImmediate(()=>srv.serveIn(app)) : cds.on('bootstrap', app => srv.serveIn(app))
  }
}



/**
 * Returns a trace logger for the given module if trace is switched on for it,
 * otherwise returns null. All cds runtime packages use this method for their
 * trace and debug output. It can also be used in applications like that:
 *
 *    const LOG = cds.log('sql')
 *    LOG._info && LOG.info ('whatever', you, 'like...')
 *
 * You can also specify alternate module names:
 *
 *    const LOG = cds.log('db|sql')
 *
 * Tracing can be switched on/off through env variable DEBUG:
 * Set it to a comma-separated list of modules to switch on tracing.
 * Set it to 'all' or 'y' to switch on tracing for all modules.
 *
 * @param {string} [module] the module for which a logger is requested
 * @param {string|number|{ level }} [level]  the log level to enable -> 0=off, 1=error, 2=warn, 3=info, 4=debug, 5=trace
 */
module.exports = exports = function cds_log (module, level) { // NOSONAR
  const id = module ? module.match(/^[^|]+/)[0] : 'cds'
  const logger = cached[id]; if (logger && !level) return logger
  if (typeof level === 'object') level = level.level
  if (!level) level = (
    process.env.DEBUG && process.env.DEBUG.match(RegExp(`\\b(y|all|${module||'any'})\\b`)) ? DEBUG :
    log.levels[id] || INFO
  )
  if (typeof level === 'string') {
    level = exports.levels [level.toUpperCase()]
  }
  if (logger && logger.level === level) return logger
  return cached[id] = new Logger (id,level)
}


/**
 * Shortcut to `cds.log(...).debug`, returning undefined if `cds.log(...)._debug` is false.
 * @param {string} [module] the module for which a logger is requested
 * @param {string|{ level, prefix }} [prefix] a prefix to prepend to each log output, default: '[cds.<module>] -'
 */
exports.debug = function cds_debug (module) {
  const L = this.log (module)
  return L._debug && L.debug
}


/**
 * Constructs a new Logger with the method signature of `{ debug, log, info, warn, error }`
 * from console. The default implementation actually maps it to `global.console`.
 * You can assign different implementations, e.g. to integrate with advanced
 * logging frameworks, for example like that:
 *
 *    cds.log.Logger = () => winston.createLogger (...)
 *
 * @param {string} [module] the module for which a logger is requested
 * @param {number} [level]  the log level to enable -> 0=off, 1=error, 2=warn, 3=info, 4=debug, 5=trace
 */
/* eslint-disable no-console */
exports.Logger = (module, level) => {
  const fmt = (level,args) => log.format (module,level,...args)
  const log = Object.assign ({
    format: exports.format,
    trace:  level < TRACE ? ()=>{} : (...args) => console.trace (...fmt(TRACE,args)),
    debug:  level < DEBUG ? ()=>{} : (...args) => console.debug (...fmt(DEBUG,args)),
    log:    level < INFO  ? ()=>{} : (...args) => console.log (...fmt(INFO,args)),
    info:   level < INFO  ? ()=>{} : (...args) => console.log (...fmt(INFO,args)),
    warn:   level < WARN  ? ()=>{} : (...args) => console.warn (...fmt(WARN,args)),
    error:  level < ERROR ? ()=>{} : (...args) => console.error (...fmt(ERROR,args)),
    _trace: level >= TRACE,
    _debug: level >= DEBUG,
    _info:  level >= INFO,
    _warn:  level >= WARN,
    _error: level >= ERROR,
  }, !cds.app && { // in case of cds compile, all log output goes to stderr
    debug:  level < DEBUG ? ()=>{} : (...args) => console.warn (...fmt(DEBUG,args)),
    log:    level < INFO  ? ()=>{} : (...args) => console.warn (...fmt(INFO,args)),
    info:   level < INFO  ? ()=>{} : (...args) => console.warn (...fmt(INFO,args)),
  })
  return log
}


/**
 * Formats a log outputs by returning an array of arguments which are passed to
 * console.log() et al.
 * You can assign custom formatters like that:
 *
 *    cds.log.format = (module, level, ...args) => [ '[', module, ']', ...args ]
 *
 * @param {string} module the module for which a logger is requested
 * @param {number} level  the log level to enable -> 0=off, 1=error, 2=warn, 3=info, 4=debug, 5=trace
 * @param {any[]} args  the arguments passed to Logger.debug|log|info|wanr|error()
 */
exports.format = (module, level, ...args) => [ `[${module}] -`, ...args ]


/**
 * Helper fundcion to construct new Loggers, updating an already cached one
 * with new log levels, if exists.
 */
function Logger (id,level,prefix) {
  const logger = exports.Logger (id, level, prefix)
  return Object.assign (cached[id] || logger.log, logger, {
    id, level, prefix, setFormat(fn){ logger.format = fn }
  })
}


const { ERROR, WARN, INFO, DEBUG, TRACE } = exports.levels = {
  SILENT:0, ERROR:1, WARN:2, INFO:3, DEBUG:4, TRACE:5, SILLY:5, VERBOSE:5
}
const cached = exports.loggers = {}

Object.defineProperty (exports,'cache',{
  configurable: true,
  get(){
    Object.defineProperty (exports,'cache',{value:cached})
    console.trace(`
    -----------------------------------------------------------------

      WARNING: You are using inofficial and removed cds.log.cache,
      which was already removed -> please fix this coding.

    -----------------------------------------------------------------
    `)
    return cached
  }
})
