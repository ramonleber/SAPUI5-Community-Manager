const cds = require('../../../cds')

const { getBackLinks, isSelfManaged, getOnCondElements, isBacklink } = require('./backlinks')
const { isDraftEnabled, ensureNoDraftsSuffix, ensureDraftsSuffix } = require('../draft')
const { deepCopyObject, deepCopyArray } = require('../copy')
const { getTransition, getDBTable } = require('../../utils/resolveView')
const cqn2cqn4sql = require('../../../common/utils/cqn2cqn4sql')
const { getEntityNameFromDeleteCQN } = require('../../../common/utils/cqn')

const getError = require('../../../common/error')

const isRootEntity = (definitions, entityName) => {
  const entity = definitions[entityName]
  if (!entity) return false

  // TODO: There can be unmanaged relations to some parent -> not detected by the following code
  const associationElements = Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(element => element._isAssociationEffective)

  for (const { target } of associationElements) {
    const parentEntity = definitions[target]
    for (const parentElementName in parentEntity.elements) {
      const parentElement = parentEntity.elements[parentElementName]
      if (
        parentElement._isCompositionEffective &&
        parentElement.target === entityName &&
        !(parentElement.parent && ensureNoDraftsSuffix(parentElement.parent.name) === entityName)
      ) {
        return false
      }
    }
  }
  return true
}

const getCompositionRoot = (definitions, entity) => {
  const associationElements = Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(element => element._isAssociationEffective)

  for (const { target } of associationElements) {
    const parentEntity = definitions[target]
    for (const parentElementName in parentEntity.elements) {
      const parentElement = parentEntity.elements[parentElementName]
      if (
        parentElement._isCompositionEffective &&
        parentElement.target === entity.name &&
        parentElement.target !== ensureNoDraftsSuffix(parentElement.parent.name)
      ) {
        return getCompositionRoot(definitions, parentEntity)
      }
    }
  }
  return entity
}

const _addNavigationToCompositionElements = (element, definitions, compositionTree, compositionMap, isManaged) => {
  const links = element.is2one ? getBackLinks(element) : []

  const compositionElement = Object.assign({}, compositionMap.get(element.target), { name: element.name, links })
  const backLinks = element.is2many ? getBackLinks(element) : []

  if (isManaged) {
    compositionElement.backLinks = backLinks
  } else {
    compositionElement.customBackLinks = backLinks
  }

  compositionTree.compositionElements.push(compositionElement)
}

const _navigationExistsInCompositionMap = (element, compositionMap, includeAssociations) => {
  return (
    compositionMap.has(element.target) &&
    (element._isCompositionEffective || (includeAssociations && element._isAssociationEffective))
  )
}

const _isNonRecursiveNavigation = (element, rootEntityName, includeAssociations) => {
  return (
    rootEntityName !== element.target &&
    (element._isCompositionEffective || (includeAssociations && element._isAssociationEffective))
  )
}

const _is2OneManaged = element => {
  return element.is2one && _isManaged(element)
}

const _isManaged = element => {
  return isSelfManaged(element) || !element.on
}

const _isUnManaged = element => {
  return element.on && !isSelfManaged(element)
}

const _getLinks = (element, definitions) => {
  return element.is2one && !isSelfManaged(element) ? getBackLinks(element) : []
}

const _isAssocComp = (element, parent) => {
  return (
    // REVISIT: are all three checks really required?
    element.target === parent.name && element.isAssociation && element.on
  )
}

const _checkIfBackLink = (element, definitions) => {
  const target = definitions[element.target]
  for (const elementName in target.elements) {
    const targetElement = target.elements[elementName]
    if (_isAssocComp(targetElement, element.parent)) {
      const onCondElements = getOnCondElements(targetElement.on)
      for (const el of onCondElements) {
        const { entityKey, targetKey } = el
        if (entityKey === `${elementName}.${element.name}` || targetKey === `${elementName}.${element.name}`) {
          return true
        }
      }
      return false
    }
  }
}

const _addBackLinksToCompositionTree = (element, definitions, compositionTree) => {
  if (_isUnManaged(element)) {
    if (_checkIfBackLink(element, definitions)) {
      const backLinks = getBackLinks(element).map(backLink => ({
        entityKey: backLink.targetKey,
        targetKey: backLink.entityKey,
        entityVal: backLink.targetVal,
        targetVal: backLink.entityVal
      }))
      compositionTree.customBackLinks.push(...backLinks)
    }
  } else {
    compositionTree.backLinks.push(...getBackLinks(element))
  }
}

const _skipPersistence = (element, definitions) => definitions[element.target]._hasPersistenceSkip

const _createSubElement = (element, definitions, parentEntityName) => {
  const links = _getLinks(element, definitions)
  const backLinks = []
  const subObject = { name: element.name, backLinks, links }

  if (_skipPersistence(element, definitions)) {
    subObject.skipPersistence = true
  }

  if (_isUnManaged(element)) {
    subObject.customBackLinks = getBackLinks(element)
  }

  return subObject
}

const _resolvedElement = element => {
  if (!element.target) return element
  // skip forbidden view check if association to view with foreign key in target
  const skipForbiddenViewCheck = element._isAssociationStrict && element.on && !element['@odata.contained']
  const { target, mapping } = getTransition(element._target, undefined, skipForbiddenViewCheck)
  const newElement = { target: target.name, _target: target }
  Object.setPrototypeOf(newElement, element)
  if (element.on) {
    newElement.on = element.on.map(onEl => {
      if (!onEl.ref || onEl.ref[0] !== element.name) return onEl
      const mapped = mapping.get(onEl.ref[1])
      if (!mapped || !mapped.ref) return onEl
      const newRef = [onEl.ref[0], mapped.ref[0]]
      return { ...onEl, ...{ ref: newRef } }
    })
  }
  return newElement
}

const _getCompositionTreeRec = ({
  rootEntityName,
  definitions,
  compositionMap,
  compositionTree,
  entityName,
  parentEntityName,
  includeAssociations,
  resolveViews
}) => {
  compositionMap.set(parentEntityName, compositionTree)
  compositionTree.source = parentEntityName
  if (parentEntityName !== rootEntityName) {
    compositionTree.target = entityName
  }
  compositionTree.compositionElements = []
  compositionTree.backLinks = compositionTree.backLinks || []
  compositionTree.customBackLinks = compositionTree.customBackLinks || []

  const parentEntity = definitions[parentEntityName]
  const elements = Object.keys(parentEntity.elements).map(key => parentEntity.elements[key])

  for (const element of elements) {
    const el = resolveViews ? _resolvedElement(element) : element
    if (_navigationExistsInCompositionMap(el, compositionMap, includeAssociations)) {
      _addNavigationToCompositionElements(el, definitions, compositionTree, compositionMap, _isManaged(el))
    } else if (_isNonRecursiveNavigation(el, rootEntityName, includeAssociations)) {
      const subObject = _createSubElement(el, definitions, parentEntityName)

      compositionTree.compositionElements.push(subObject)

      _getCompositionTreeRec({
        rootEntityName,
        definitions,
        compositionMap,
        compositionTree: subObject,
        entityName: parentEntityName,
        parentEntityName: el.target,
        includeAssociations: false
      })
    } else if (
      el._isAssociationEffective &&
      el.target === compositionTree.target &&
      isBacklink(el, el._target) &&
      compositionMap.has(el.target)
    ) {
      _addBackLinksToCompositionTree(el, definitions, compositionTree)
    }
  }
}

const _removeLocalizedTextsFromDraftTree = (compositionTree, definitions, checkedEntities = new Set()) => {
  for (const e of compositionTree.compositionElements) {
    if (checkedEntities.has(e.source)) {
      return
    }

    const target = definitions[e.target]
    if (e.name === 'texts' && target.elements.localized && !target['@fiori.draft.enabled']) {
      compositionTree.compositionElements.splice(compositionTree.compositionElements.indexOf(e), 1)
    } else {
      checkedEntities.add(e.source)
      _removeLocalizedTextsFromDraftTree(e, definitions, checkedEntities)
    }
  }
}

const memoizeGetCompositionTree = fn => {
  const cache = new Map()
  return ({ definitions, rootEntityName, checkRoot = true, includeAssociations = false, resolveViews = false }) => {
    const key = [rootEntityName, checkRoot, includeAssociations].join('#')

    const map = cache.get(definitions)
    const cachedResult = map && map.get(key)
    if (cachedResult) return cachedResult

    const compTree = fn({ definitions, rootEntityName, checkRoot, includeAssociations, resolveViews })

    const _map = map || new Map()
    _map.set(key, compTree)
    if (!map) cache.set(definitions, _map)
    return compTree
  }
}

const _resolvedEntityName = (entityName, definitions) => {
  const target = definitions[entityName]
  if (!target) return entityName
  const resolved = getDBTable(target)
  return resolved.name
}

const _getCompositionTree = ({
  definitions,
  rootEntityName,
  checkRoot = true,
  includeAssociations = false,
  resolveViews = false
}) => {
  const rootName = resolveViews ? _resolvedEntityName(rootEntityName, definitions) : rootEntityName

  if (checkRoot && !isRootEntity(definitions, rootEntityName)) {
    throw getError(`Entity "${rootEntityName}" is not root entity`)
  }
  const compositionTree = {}
  _getCompositionTreeRec({
    rootEntityName: rootName,
    definitions,
    compositionMap: new Map(),
    compositionTree,
    entityName: rootName,
    parentEntityName: rootName,
    includeAssociations,
    resolveViews
  })

  if (isDraftEnabled(definitions[rootEntityName])) {
    _removeLocalizedTextsFromDraftTree(compositionTree, definitions)
  }

  return compositionTree
}

/**
 * Provides tree of all compositions. (Cached)
 *
 * @param {object} definitions Definitions of the reflected model
 * @param {string} rootEntityName Name of the root entity
 * @param {boolean} checkRoot Check is provided entity is a root
 * @returns {object} tree of all compositions
 * @throws Error if no valid root entity provided
 */
const getCompositionTree = memoizeGetCompositionTree(_getCompositionTree)

const _addDraftSuffix = (draft, name) => {
  return draft ? ensureDraftsSuffix(name) : ensureNoDraftsSuffix(name)
}

const _dataElements = entity => {
  // REVISIT: this is expensive
  return Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(e => !e.virtual && !e.isAssociation)
}

const _keyElements = entity => {
  // REVISIT: this is expensive
  return Object.keys(entity.keys)
    .map(key => entity.keys[key])
    .filter(e => !e.virtual && !e.isAssociation)
}

const _isCompOrAssoc = (entity, k, onlyToOne) => {
  // REVISIT: this is expensive
  return (
    entity.elements &&
    entity.elements[k] &&
    entity.elements[k].isAssociation &&
    ((onlyToOne && entity.elements[k].is2one) || !onlyToOne)
  )
}

const _cleanDeepData = (entity, data, onlyToOne = false) => {
  if (!Array.isArray(data)) {
    return _cleanDeepData(entity, [data], onlyToOne)[0]
  }
  return data.map(entry => {
    return Object.keys(entry || {}).reduce((result, k) => {
      if (!_isCompOrAssoc(entity, k, onlyToOne)) {
        result[k] = entry[k]
      }
      return result
    }, {})
  })
}

const _key = (entity, data) => {
  return _keyElements(entity).reduce((result, element) => {
    result[element.name] = data[element.name]
    return result
  }, {})
}

const _keys = (entity, data) => {
  return data.map(entry => {
    return _key(entity, entry)
  })
}

const _parentKey = (element, key) => {
  const parentKey = {}

  element.customBackLinks.reduce((parentKey, customBackLink) => {
    parentKey[customBackLink.entityKey] = key[customBackLink.targetKey] || customBackLink.targetVal
    return parentKey
  }, parentKey)

  return element.backLinks.reduce((parentKey, backlink) => {
    parentKey[backlink.entityKey] = key[backlink.targetKey] || backlink.targetVal
    return parentKey
  }, parentKey)
}

const _parentKeys = (element, keys) => {
  return keys.map(key => {
    return _parentKey(element, key)
  })
}

const _whereKey = key => {
  const where = []
  Object.keys(key).forEach(keyPart => {
    if (where.length > 0) {
      where.push('and')
    }
    where.push({ ref: [keyPart] }, '=', { val: key[keyPart] })
  })
  return where
}

const _whereKeys = keys => {
  const where = []
  keys.forEach(key => {
    if (where.length > 0) {
      where.push('or')
    }
    where.push('(', ..._whereKey(key), ')')
  })
  return where
}

const _findWhere = (data, where) => {
  return data.filter(entry => {
    return Object.keys(where).every(key => {
      return where[key] === entry[key]
    })
  })
}

const _diffData = (newData, oldData, entity, newEntry, oldEntry, definitions) => {
  const result = {}

  const keysSet = new Set(Object.keys(newData).concat(Object.keys(oldData)))
  for (const key of keysSet.keys()) {
    const newVal = _val(newData[key])
    const oldVal = _val(oldData[key])

    if (newVal !== undefined && newVal !== oldVal) {
      result[key] = newData[key]
      continue
    }

    // comp2one removed?
    const fk = entity.elements[key] && entity.elements[key]['@odata.foreignKey4']
    if (fk && newVal === undefined && oldVal !== undefined) {
      const nav = entity.elements[fk]
      // REVISIT: why check @cds.persistence.skip needed? bad tests?
      if (
        nav.isComposition &&
        nav.is2one &&
        newEntry[nav.name] !== undefined &&
        !definitions[nav.target]._hasPersistenceSkip
      ) {
        result[key] = null
      }
    }
  }

  return result
}

const _toManyElements = subEntity => {
  return Object.keys(subEntity.elements)
    .map(key => subEntity.elements[key])
    .filter(element => element.is2many)
}

const hasCompositionDelete = (definitions, cqn) => {
  const from = getEntityNameFromDeleteCQN(cqn)
  if (!from) return false

  const entity = definitions && definitions[ensureNoDraftsSuffix(from)]
  if (entity) return !!Object.keys(entity.elements || {}).find(k => entity.elements[k]._isCompositionEffective)

  return false
}

function _getSubWhereAndEntities(allBackLinks, links, draft, element) {
  let entity1, entity2
  const isBackLink = allBackLinks.length > 0
  const linksForWhere = isBackLink ? allBackLinks : links

  const subWhere = linksForWhere.reduce((result, backLink) => {
    // exclude static values from subwhere
    if (backLink.entityKey && !backLink.targetKey && backLink.targetVal !== undefined) {
      return result
    }
    if (result.length > 0) {
      result.push('and')
    }

    entity1 = {
      alias: 'ALIAS1',
      entityName: _addDraftSuffix(draft, element.source),
      propertyName: isBackLink ? backLink.entityKey : backLink.targetKey
    }

    const res1 = backLink.entityKey
      ? { ref: [entity1.alias, entity1.propertyName] }
      : { val: isBackLink ? backLink.entityVal : backLink.targetVal }

    entity2 = {
      alias: 'ALIAS2',
      entityName: _addDraftSuffix(draft, element.target || element.source),
      propertyName: isBackLink ? backLink.targetKey : backLink.entityKey
    }

    const res2 = backLink.targetKey
      ? { ref: [entity2.alias, entity2.propertyName] }
      : { val: isBackLink ? backLink.targetVal : backLink.entityVal }

    result.push(res1, '=', res2)
    return result
  }, [])

  return {
    subWhere,
    entity1,
    entity2
  }
}
function _getStaticWhere(allBackLinks, entity1) {
  return allBackLinks.reduce((result, backLink) => {
    if (result.length > 0) {
      result.push('and')
    }
    if (backLink.entityKey && !backLink.targetKey && backLink.targetVal !== undefined) {
      result.push({ ref: [entity1.alias, backLink.entityKey] }, '=', { val: backLink.targetVal })
    }
    return result
  }, [])
}

function _getWhereKeys(allBackLinks, entity1, is = 'not null') {
  return allBackLinks.reduce((result, backLink) => {
    // exclude static keys
    if (backLink.entityKey && !backLink.targetKey && backLink.targetVal !== undefined) {
      return result
    }
    if (result.length > 0) {
      result.push('or')
    }
    if (backLink.entityKey) {
      result.push({ ref: [entity1.alias, backLink.entityKey] }, 'is ' + is)
    } else if (backLink.entityVal !== undefined) {
      // static values should not be included
      result.pop()
    }
    return result
  }, [])
}

const csnElementFromTarget = (element, definitions) =>
  element.target && definitions[element.target].elements[element.name]

const _addSubCascadeDeleteCQN = (definitions, compositionTree, level, cqns, draft, elementSet = new Set()) => {
  for (const element of compositionTree.compositionElements) {
    if (element.skipPersistence) continue

    const fqn = compositionTree.source + ':' + element.name
    if (elementSet.has(fqn)) {
      // recursion -> abort
      continue
    }

    // REVISIT: sometimes element.target is undefined which leads to self join
    if (!element.target) element.target = compositionTree.source

    const allBackLinks = [...element.backLinks, ...element.customBackLinks]
    const { entity1, entity2, subWhere } = _getSubWhereAndEntities(allBackLinks, element.links, draft, element)

    let whereKeys = _getWhereKeys(allBackLinks, entity1)
    const staticWhereValues = _getStaticWhere(allBackLinks, entity1)
    if (allBackLinks.length > 0 || element.links.length > 0) {
      const where = []

      if (whereKeys.length === 0 && element.links.length === 1) {
        // add is null check for each unused backlink
        for (const ce of compositionTree.compositionElements) {
          if (ce.source !== element.source) continue
          if (ce.name === element.name) continue
          const wk = _getWhereKeys([...ce.backLinks, ...ce.customBackLinks], entity1, 'null')
          if (whereKeys.length === 0) whereKeys = wk
          else whereKeys.push('and', ...wk)
        }
      }

      if (whereKeys.length > 0) {
        where.push('(', ...whereKeys, ')', 'and')
      }
      if (staticWhereValues.length > 0) {
        where.push('(', ...staticWhereValues, ')', 'and')
      }

      where.push('not exists', {
        SELECT: {
          columns: [{ val: 1, as: '_exists' }],
          from: { ref: [entity2.entityName], as: entity2.alias },
          where: subWhere
        }
      })
      const subCQN = { DELETE: { from: { ref: [entity1.entityName], as: entity1.alias }, where: where } }

      if (cds.env.features._foreign_key_constraints) {
        // deep delete should be handled by database constraints
        // return [[cqn]]
        const csnElement = csnElementFromTarget(element, definitions)

        // TODO: only managed to-one should be filtered, unmanaged with key in children can be ignored
        if (csnElement && _is2OneManaged(csnElement)) {
          cqns[level] = cqns[level] || []
          cqns[level].push(subCQN)
        }
      } else {
        cqns[level] = cqns[level] || []
        cqns[level].push(subCQN)
      }

      elementSet.add(fqn)

      _addSubCascadeDeleteCQN(definitions, element, level + 1, cqns, draft, elementSet)
    }
  }

  return cqns
}

const createCascadeDeleteCQNs = (definitions, cqn) => {
  const from = getEntityNameFromDeleteCQN(cqn)
  if (!from) return [[cqn]]

  const entityName = ensureNoDraftsSuffix(from)
  // REVISIT: baaad check!
  const draft = entityName !== from
  const compositionTree = getCompositionTree({
    definitions,
    rootEntityName: entityName,
    checkRoot: false,
    resolveViews: !draft
  })

  return [[cqn], ..._addSubCascadeDeleteCQN(definitions, compositionTree, 0, [], draft)]
}

function _hasCompOrAssocIgnoreEmptyToMany(entity, k, data) {
  // TODO once REST also uses same logic as odata structured check if we can omit 'entity.elements[k] &&'
  return entity.elements[k] && (entity.elements[k].is2one || (entity.elements[k].is2many && data[k] && data[k].length))
}

const hasDeepInsert = (definitions, cqn) => {
  if (cqn && cqn.INSERT && cqn.INSERT.into && cqn.INSERT.entries) {
    const entityName = ensureNoDraftsSuffix(cqn.INSERT.into.name || cqn.INSERT.into)
    const entity = definitions && definitions[entityName]
    if (entity) {
      return !!cqn.INSERT.entries.find(entry => {
        return !!Object.keys(entry || {}).find(k => {
          return _hasCompOrAssocIgnoreEmptyToMany(entity, k, entry)
        })
      })
    }
  }
  return false
}

const _addSubDeepInsertCQN = (definitions, compositionTree, data, cqns, draft) => {
  compositionTree.compositionElements.forEach(element => {
    if (element.skipPersistence) {
      return
    }
    // element source must be changed in comp tree
    const subEntity = definitions[element.source]
    const into = _addDraftSuffix(draft, subEntity.name)
    const insertCQN = { INSERT: { into: into, entries: [] } }
    const subData = data.reduce((result, entry) => {
      if (element.name in entry) {
        const elementValue = _val(entry[element.name])
        // remove empty entries
        const subData = _array(elementValue).filter(ele => Object.keys(ele).length > 0)

        if (subData.length > 0) {
          // REVISIT: this can make problems
          insertCQN.INSERT.entries.push(..._cleanDeepData(subEntity, subData))
          result.push(...subData)
        }
      }
      return result
    }, [])
    if (insertCQN.INSERT.entries.length > 0) {
      cqns.push(insertCQN)
    }
    if (subData.length > 0) {
      _addSubDeepInsertCQN(definitions, element, subData, cqns, draft)
    }
  })
  return cqns
}

const _checkForToManyAssociation = (toManyElements, dataEntry, event) => {
  for (const toManyElement of toManyElements) {
    if (toManyElement._isAssociationEffective && dataEntry[toManyElement.name] !== undefined) {
      throw getError(400, `Deep ${event} with to-many association is not allowed`)
    }
  }
}

const createDeepInsertCQNs = (definitions, cqn) => {
  const into = cqn.INSERT.into.name || cqn.INSERT.into
  const entityName = ensureNoDraftsSuffix(into)
  const draft = entityName !== into
  const dataEntries = cqn.INSERT.entries ? deepCopyArray(cqn.INSERT.entries) : []
  const entity = definitions && definitions[entityName]
  const compositionTree = getCompositionTree({
    definitions,
    rootEntityName: entityName,
    checkRoot: false,
    includeAssociations: !draft,
    resolveViews: !draft
  })

  const flattenedCqn = { INSERT: Object.assign({}, cqn.INSERT) }
  flattenedCqn.INSERT.entries = []

  const toManyElements = _toManyElements(entity)
  for (const dataEntry of dataEntries) {
    _checkForToManyAssociation(toManyElements, dataEntry, 'insert')

    flattenedCqn.INSERT.entries.push(_cleanDeepData(entity, Object.assign({}, dataEntry)))
  }
  return [flattenedCqn, ..._addSubDeepInsertCQN(definitions, compositionTree, dataEntries, [], draft)]
}

const hasDeepUpdate = (definitions, cqn) => {
  if (cqn && cqn.UPDATE && cqn.UPDATE.entity && (cqn.UPDATE.data || cqn.UPDATE.with)) {
    const entityName =
      (cqn.UPDATE.entity.ref && cqn.UPDATE.entity.ref[0]) || cqn.UPDATE.entity.name || cqn.UPDATE.entity
    const entity = definitions && definitions[ensureNoDraftsSuffix(entityName)]
    if (entity) {
      return !!Object.keys(Object.assign({}, cqn.UPDATE.data || {}, cqn.UPDATE.with || {})).find(k => {
        return _isCompOrAssoc(entity, k)
      })
    }
  }
  return false
}

function _selectDeepUpdateDataRecursion({ definitions, compositionTree, entityName, data, result, draft, execute }) {
  const entity = definitions && definitions[entityName]
  const keys = _keys(entity, result)
  const promises = compositionTree.compositionElements.map(element => {
    if (element.skipPersistence) {
      return Promise.resolve()
    }

    if (data !== undefined && !data.find(entry => element.name in entry)) {
      return Promise.resolve()
    }

    const subData =
      data &&
      data.reduce((result, entry) => {
        if (element.name in entry) {
          const elementValue = _val(entry[element.name])
          result.push(..._array(elementValue))
        }
        return result
      }, [])

    let where
    if (element.links && element.links.length > 0) {
      where = []

      for (const row of result) {
        if (where.length > 0) {
          where.push('or')
        }

        const whereObj = element.links.reduce((res, currentLink) => {
          res[currentLink.targetKey] = row[currentLink.entityKey]
          return res
        }, {})
        where.push('(', ..._whereKey(whereObj), ')')
      }
    }

    const entityName = element.source
    const parentKeys = _parentKeys(element, keys)

    return _selectDeepUpdateData({
      definitions,
      compositionTree: element,
      entityName,
      data: subData,
      where,
      selectData: result,
      parentKeys,
      draft,
      execute
    })
  })

  return Promise.all(promises)
}

const _selectDeepUpdateDataResult = ({
  definitions,
  compositionTree,
  entityName,
  data,
  selectData,
  root,
  draft,
  result,
  execute
}) => {
  if (root) {
    selectData.push(...result)
  } else {
    selectData.forEach(selectEntry => {
      selectEntry[compositionTree.name] = selectEntry[compositionTree.name] || []
      let pk = _parentKey(compositionTree, selectEntry)

      // adjust pk for nested composition of one
      if (!pk || Object.keys(pk).length === 0) {
        const parent = definitions[compositionTree.target]
        const assoc = (parent && parent.elements[compositionTree.name]) || {}
        if (assoc.isComposition && assoc.is2one && compositionTree.links.length === 1) {
          pk = { [compositionTree.links[0].targetKey]: selectEntry[compositionTree.links[0].entityKey] }
        }
      }

      selectEntry[compositionTree.name].push(..._findWhere(result, pk))
    })
  }

  if (result.length === 0) {
    return Promise.resolve()
  }

  return _selectDeepUpdateDataRecursion({
    definitions,
    compositionTree,
    entityName,
    data,
    result,
    draft,
    execute
  })
}

const _getLinksOfCompTree = compositionTree => {
  const links = []
  for (const compElement of compositionTree.compositionElements || []) {
    for (const link of compElement.links || []) {
      links.push(link.entityKey)
    }
  }
  return links
}

const _selectDeepUpdateData = ({
  definitions,
  compositionTree,
  entityName,
  data,
  selectData,
  where,
  orderBy,
  parentKeys,
  draft,
  execute,
  includeAllRootColumns,
  singleton,
  alias
}) => {
  const root = !selectData
  const entity = definitions && definitions[entityName]
  const from = _addDraftSuffix(draft, entity.name)
  const selectCQN = { SELECT: { from: { ref: [from] } } }
  if (alias) selectCQN.SELECT.from.as = alias
  const links = _getLinksOfCompTree(compositionTree)
  if (data !== undefined) {
    selectCQN.SELECT.columns = []
    const backLinkKeys = [
      ...compositionTree.backLinks.map(backLink => backLink.entityKey),
      ...compositionTree.customBackLinks.map(customBackLink => customBackLink.entityKey)
    ]
    _dataElements(entity).forEach(element => {
      if (
        element.key ||
        links.includes(element.name) ||
        backLinkKeys.includes(element.name) ||
        (includeAllRootColumns && root) ||
        data.find(entry => element.name in entry)
      ) {
        selectCQN.SELECT.columns.push({ ref: [element.name] })
      }
    })
  }

  if (where) {
    selectCQN.SELECT.where = where
  } else if (parentKeys) {
    selectCQN.SELECT.where = _whereKeys(parentKeys)
  }

  if (orderBy) {
    selectCQN.SELECT.orderBy = orderBy
  }

  if (singleton) {
    selectCQN.SELECT.limit = { rows: { val: 1 } }
  }

  selectData = selectData || []

  // REVISIT: remove once SELECT builder does flattening!
  const select = cqn2cqn4sql(selectCQN, { definitions })

  // REVISIT: don't carry along execute, but get db tx here (via cds.context, for example) and run
  return execute(select)
    .then(result => {
      return _selectDeepUpdateDataResult({
        definitions,
        compositionTree,
        entityName,
        data,
        selectData,
        where,
        parentKeys,
        root,
        result,
        draft,
        execute
      })
    })
    .then(() => {
      return selectData
    })
}

const _isSameEntity = (definitions, cqn, req) => {
  const where = cqn.UPDATE.where || []
  const persistentObj = Array.isArray(req._.partialPersistentState)
    ? req._.partialPersistentState[0]
    : req._.partialPersistentState
  if (!persistentObj) {
    // If no data was found we don't know if it is the same entity
    return false
  }
  const target = getDBTable(req.target)
  if (target.name !== (cqn.UPDATE.entity.ref && cqn.UPDATE.entity.ref[0]) && target.name !== cqn.UPDATE.entity) {
    return false
  }
  for (let i = 0; i < where.length; i++) {
    if (!where[i] || !where[i].ref || !target.elements[where[i].ref]) {
      continue
    }
    const key = where[i].ref
    const val = where[i + 2].val
    const sign = where[i + 1]
    // eslint-disable-next-line
    if (target.elements[key].key && key in persistentObj && sign === '=' && val !== persistentObj[key]) {
      return false
    }
  }
  return true
}

const _from = query =>
  (query.UPDATE.entity.ref && query.UPDATE.entity.ref[0]) || query.UPDATE.entity.name || query.UPDATE.entity

const selectDeepUpdateData = (definitions, cqn, execute, req, includeAllRootColumns = false) => {
  // REVISIT this should be done somewhere before, so it is not done twice for deep updates
  const sqlQuery = cqn2cqn4sql(cqn, { definitions })

  if (req && _isSameEntity(definitions, sqlQuery, req)) {
    return Promise.resolve(req._.partialPersistentState)
  }

  const from = _from(sqlQuery)
  const alias = sqlQuery.UPDATE.entity.as
  const where = sqlQuery.UPDATE.where || []
  const entityName = ensureNoDraftsSuffix(from)
  const draft = entityName !== from

  const orderBy = req && req.target && req.target.query && req.target.query.SELECT && req.target.query.SELECT.orderBy
  const data = Object.assign({}, sqlQuery.UPDATE.data || {}, cqn.UPDATE.with || {})
  const compositionTree = getCompositionTree({
    definitions,
    rootEntityName: entityName, // REVISIT: drafts are resolved too eagerly
    checkRoot: false,
    includeAssociations: !draft,
    resolveViews: !draft
  })

  return _selectDeepUpdateData({
    definitions,
    compositionTree,
    entityName,
    data: [data],
    where,
    orderBy,
    draft,
    execute,
    includeAllRootColumns,
    singleton: req && req.target && req.target._isSingleton,
    alias
  })
}

function _addSubDeepUpdateCQNForDelete({ entity, data, selectData, deleteCQN }) {
  const dataByKey = _dataByKey(entity, data)
  for (const selectEntry of selectData) {
    const dataEntry = dataByKey.get(_serializedKey(entity, selectEntry))
    if (!dataEntry) {
      if (deleteCQN.DELETE.where.length > 0) {
        deleteCQN.DELETE.where.push('or')
      }
      deleteCQN.DELETE.where.push('(', ..._whereKey(_key(entity, selectEntry)), ')')
    }
  }
}

function _fillLinkFromStructuredData(entity, entry) {
  for (const elementName in entity.elements) {
    const foreignKey4 = entity.elements[elementName]['@odata.foreignKey4']
    if (foreignKey4 && entry[foreignKey4]) {
      const foreignKey = entity.elements[elementName].name
      const childKey = foreignKey.split('_')[1]
      const val = _unwrapVal(entry[foreignKey4])[childKey]
      if (val !== undefined) entry[foreignKey] = val
    }
  }
}

function _addSubDeepUpdateCQNForUpdateInsert({
  entity,
  entityName,
  data,
  selectData,
  updateCQNs,
  insertCQN,
  definitions
}) {
  const selectDataByKey = _dataByKey(entity, selectData)
  const deepUpdateData = []
  for (const entry of data) {
    const key = _key(entity, entry)
    const selectEntry = selectDataByKey.get(_serializedKey(entity, entry))
    _fillLinkFromStructuredData(entity, entry)
    if (selectEntry) {
      deepUpdateData.push(entry)
      const newData = _cleanDeepData(entity, entry)
      const oldData = _cleanDeepData(entity, selectEntry)
      const diff = _diffData(newData, oldData, entity, entry, selectEntry, definitions)
      // empty updates will be removed later
      updateCQNs.push({ UPDATE: { entity: entityName, data: diff, where: _whereKey(key) } })
    } else {
      insertCQN.INSERT.entries.push(entry)
      // inserts are handled deep so they must not be put into deepUpdateData
    }
  }
  return deepUpdateData
}

function _addSubDeepUpdateCQNCollectDelete(deleteCQNs, cqns, index) {
  deleteCQNs.forEach(deleteCQN => {
    if (
      !cqns.find((subCQNs, subIndex) => {
        if (subIndex > 0) {
          const deleteIndex = subCQNs.findIndex(cqn => {
            return cqn.DELETE && cqn.DELETE.from === deleteCQN.DELETE.from
          })
          if (deleteIndex > -1) {
            if (subIndex < index) {
              subCQNs.splice(deleteIndex, 1)
            } else {
              return true
            }
          }
        }
        return false
      })
    ) {
      cqns[index] = cqns[index] || []
      cqns[index].push(deleteCQN)
    }
  })
}

const _dataByKey = (entity, data) => {
  const dataByKey = new Map()
  for (const entry of data) {
    dataByKey.set(_serializedKey(entity, entry), entry)
  }
  return dataByKey
}

const _serializedKey = (entity, data) => {
  return JSON.stringify(
    _keyElements(entity)
      .map(key => key.name)
      .sort()
      .map(keyName => data[keyName])
  )
}

function _addSubDeepUpdateCQNCollect(definitions, cqns, updateCQNs, insertCQN, deleteCQN) {
  if (updateCQNs.length > 0) {
    cqns[0] = cqns[0] || []
    cqns[0].push(...updateCQNs)
  }
  if (insertCQN.INSERT.entries.length > 0) {
    cqns[0] = cqns[0] || []
    createDeepInsertCQNs(definitions, insertCQN).forEach(insertCQN => {
      const intoCQN = cqns[0].find(cqn => {
        return cqn.INSERT && cqn.INSERT.into === insertCQN.INSERT.into
      })
      if (!intoCQN) {
        cqns[0].push(insertCQN)
      } else {
        intoCQN.INSERT.entries.push(...insertCQN.INSERT.entries)
      }
    })
  }

  if (deleteCQN.DELETE.where.length > 0) {
    cqns[0] = cqns[0] || []
    cqns[0].push(deleteCQN)
    createCascadeDeleteCQNs(definitions, deleteCQN).forEach((deleteCQNs, index) => {
      if (index > 0) {
        _addSubDeepUpdateCQNCollectDelete(deleteCQNs, cqns, index)
      }
    })
  }
}

const _val = element => (element && element.val) || element

const _array = x => (Array.isArray(x) ? x : [x])

const _unwrapIfNotArray = x => (Array.isArray(x) ? x : _unwrapVal(x))

const _unwrapVal = obj => {
  for (const key in obj) {
    const value = obj[key]
    if (value && value.val) obj[key] = value.val
  }
  return obj
}

const _addToData = (subData, entity, element, entry) => {
  const value = _val(entry[element.name])
  const subDataEntries = _array(value)
  const unwrappedSubData = subDataEntries.map(entry => _unwrapIfNotArray(entry))
  subData.push(...unwrappedSubData)
}

function _addSubDeepUpdateCQNRecursion({ definitions, compositionTree, entity, data, selectData, cqns, draft }) {
  const selectDataByKey = _dataByKey(entity, selectData)
  for (const element of compositionTree.compositionElements) {
    const subData = []
    const selectSubData = []
    for (const entry of data) {
      if (element.name in entry) {
        _addToData(subData, entity, element, entry)
        const selectEntry = selectDataByKey.get(_serializedKey(entity, entry))
        if (selectEntry && element.name in selectEntry) {
          _addToData(selectSubData, entity, element, selectEntry)
        }
      }
    }
    _addSubDeepUpdateCQN({
      definitions,
      compositionTree: element,
      data: subData,
      selectData: selectSubData,
      cqns,
      draft
    })
  }
  return cqns
}

const _addSubDeepUpdateCQN = ({ definitions, compositionTree, data, selectData, cqns, draft }) => {
  // We handle each level for deepUpdate, the moment we see that there will be an INSERT,
  // it'll be removed from our deepUpdateData (and handled deep separately).
  const entity = definitions && definitions[compositionTree.source]

  if (entity._hasPersistenceSkip) return Promise.resolve()

  const entityName = _addDraftSuffix(draft, entity.name)
  const updateCQNs = []
  const insertCQN = { INSERT: { into: entityName, entries: [] } }
  const deleteCQN = { DELETE: { from: entityName, where: [] } }
  _addSubDeepUpdateCQNForDelete({ entity, data, selectData, deleteCQN })
  const deepUpdateData = _addSubDeepUpdateCQNForUpdateInsert({
    entity,
    entityName,
    data,
    selectData,
    updateCQNs,
    insertCQN,
    definitions
  })
  _addSubDeepUpdateCQNCollect(definitions, cqns, updateCQNs, insertCQN, deleteCQN)

  if (deepUpdateData.length === 0) {
    return Promise.resolve()
  }
  return _addSubDeepUpdateCQNRecursion({
    definitions,
    compositionTree,
    entity,
    data: deepUpdateData,
    selectData,
    cqns,
    draft
  })
}

const createDeepUpdateCQNs = (definitions, cqn, selectData) => {
  if (!Array.isArray(selectData)) selectData = [selectData]

  if (selectData.length === 0) return []

  if (selectData.length > 1) throw getError('Deep update can only be performed on a single instance')

  const cqns = []
  const from = (cqn.UPDATE.entity.ref && cqn.UPDATE.entity.ref[0]) || cqn.UPDATE.entity.name || cqn.UPDATE.entity
  const entityName = ensureNoDraftsSuffix(from)
  const draft = entityName !== from
  const data = cqn.UPDATE.data ? deepCopyObject(cqn.UPDATE.data) : {}
  const withObj = cqn.UPDATE.with ? deepCopyObject(cqn.UPDATE.with) : {}
  const entity = definitions && definitions[entityName]
  const entry = Object.assign({}, data, withObj, _key(entity, selectData[0]))
  const compositionTree = getCompositionTree({
    definitions,
    rootEntityName: entityName,
    checkRoot: false,
    includeAssociations: !draft,
    resolveViews: !draft
  })

  const toManyElements = _toManyElements(entity)
  _checkForToManyAssociation(toManyElements, entry, 'update')

  const subCQNs = _addSubDeepUpdateCQN({ definitions, compositionTree, data: [entry], selectData, cqns: [], draft })
  subCQNs.forEach((subCQNs, index) => {
    cqns[index] = cqns[index] || []
    cqns[index].push(...subCQNs)
  })

  // remove empty updates and inserts
  return cqns
    .map(cqns => {
      return cqns.filter(cqn => {
        if (!cqn.UPDATE && !cqn.INSERT) return true
        if (cqn.UPDATE) return Object.keys(cqn.UPDATE.data).length > 0
        if (!cqn.INSERT.entries || cqn.INSERT.entries.length > 1) return true
        return Object.keys(cqn.INSERT.entries[0]).length > 0
      })
    })
    .filter(cqns => cqns.length > 0)
}

module.exports = {
  isRootEntity,
  getCompositionTree,
  getCompositionRoot,
  hasCompositionDelete,
  hasDeepInsert,
  hasDeepUpdate,
  createCascadeDeleteCQNs,
  createDeepInsertCQNs,
  createDeepUpdateCQNs,
  selectDeepUpdateData
}
