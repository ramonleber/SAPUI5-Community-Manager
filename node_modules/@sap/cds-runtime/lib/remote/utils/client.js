const cds = require('../../cds')
const LOG = cds.log('remote')

const { revertData } = require('../../common/utils/resolveView')
const generateQuery = require('../cqn2odata')
const { convertV2ResponseData } = require('./dataConversion')

let _cloudSdkCore

const PPPD = {
  POST: 1,
  PUT: 1,
  PATCH: 1,
  DELETE: 1
}

const _executeHttpRequest = (...args) => {
  if (!_cloudSdkCore) _cloudSdkCore = require('@sap-cloud-sdk/core')

  const opts = args[1]
  if (PPPD[opts.method] && cds.env.features.fetch_csrf) {
    if (args.length === 3) args[2].fetchCsrfToken = true
    else args.push({ fetchCsrfToken: true })
  }

  return _cloudSdkCore.executeHttpRequest(...args)
}

const findServiceName = (model, ds, options) => {
  const modelServices = Object.values(model.services)

  if (options.credentials && options.credentials.service) {
    if (!modelServices.find(srv => srv.name === options.credentials.service)) {
      throw new Error(`Service "${options.credentials.service}" not found in provided model`)
    }

    return options.credentials.service
  }

  return ds
}

const createDestinationObject = (name, credentials) => {
  if (!credentials) {
    throw new Error(`No credentials configured for "${name}"`)
  }

  if (!credentials.url) {
    throw new Error(`No url configured in credentials for "${name}"`)
  }

  return { name, ...credentials }
}

const getKind = options => {
  const kind = (options.credentials && options.credentials.kind) || options.kind
  if (typeof kind === 'object') {
    return Object.keys(kind).find(key => key === 'odata' || key === 'rest')
  }

  return kind
}

/**
 * Rest Client
 */
/**
 * Normalizes server path.
 *
 * Adds / in the beginning of the path if not exists.
 * Removes / in the end of the path if exists.
 *
 * @param {*} path - to be normalized
 */
const formatPath = path => {
  let formattedPath = path
  if (!path.startsWith('/')) {
    formattedPath = `/${formattedPath}`
  }

  if (path.endsWith('/')) {
    formattedPath = formattedPath.substring(0, formattedPath.length - 1)
  }

  return formattedPath
}

const _createPostProcessor = query => {
  if (query.SELECT.columns) {
    let postProcessor
    for (const col of query.SELECT.columns) {
      if (col.as) {
        ;(postProcessor || (postProcessor = new Map())) && postProcessor.set(col.ref[col.ref.length - 1], col.as)
      }
    }

    return postProcessor
  }
}

const handleAliasInResult = (query, result) => {
  const postProcessor = _createPostProcessor(query)
  const resultArray = Array.isArray(result) ? result : [result]
  if (postProcessor) {
    for (const row of resultArray) {
      for (const col in row) {
        if (postProcessor.get(col) && postProcessor.get(col) !== col) {
          row[postProcessor.get(col)] = row[col]
          delete row[col]
        }
      }
    }
  }
}

function _defineProperty(obj, property, value) {
  const props = {}
  if (Array.isArray(obj)) {
    const _map = obj.map
    const map = (..._) => _defineProperty(_map.call(obj, ..._), property, value)
    props.map = { value: map, enumerable: false, configurable: true, writable: true }
  }
  props[property] = { value: value, enumerable: false, configurable: true, writable: true }
  for (const prop in props) {
    Object.defineProperty(obj, prop, props[prop])
  }
  return obj
}

function _normalizeMetadata(prefix, data, results) {
  const target = results || data
  const metadataKeys = Object.keys(data).filter(k => prefix.test(k))
  for (const k of metadataKeys) {
    const $ = k.replace(prefix, '$')
    _defineProperty(target, $, data[k])
    delete target[k]
  }
  if (Array.isArray(target)) {
    return target.map(row => _normalizeMetadata(prefix, row))
  }
  // check properties for all and prop.results for odata v2
  for (const [key, value] of Object.entries(target)) {
    if (value && typeof value === 'object') {
      const nestedResults = (Array.isArray(value.results) && value.results) || value
      target[key] = _normalizeMetadata(prefix, value, nestedResults)
    }
  }
  return target
}

const _purgeODataV2 = (data, target, reqHeaders) => {
  const contentType = reqHeaders['content-type']
  const ieee754Compatible = contentType && contentType.includes('IEEE754Compatible=true')
  const purgedResponse = data.results || data
  const convertedResponse = convertV2ResponseData(purgedResponse, target, ieee754Compatible)
  return _normalizeMetadata(/^__/, data, convertedResponse)
}

const _purgeODataV4 = data => {
  const purgedResponse = data.value || data
  return _normalizeMetadata(/^@odata\./, data, purgedResponse)
}

const _getPurgedOdataResponse = (data, target, reqHeaders) => {
  if (typeof data !== 'object') {
    return data
  }
  if (data && data.d) {
    return _purgeODataV2(data.d, target, reqHeaders)
  }
  return _purgeODataV4(data)
}

const _prepareErrorForLogging = (e, reqOptions) => {
  e.request = {
    method: reqOptions.method,
    url: e.config ? e.config.baseURL + e.config.url : reqOptions.url,
    headers: e.config ? e.config.headers : reqOptions.headers
  }

  if (e.response)
    e.response = { status: e.response.status, statusText: e.response.statusText, headers: e.response.headers }

  const correlationId =
    (cds.context && cds.context.id) || (reqOptions.headers && reqOptions.headers['x-correlation-id'])
  if (correlationId) e.correlationId = correlationId

  // sanatize authorization
  if (e.request.headers.authorization)
    e.request.headers.authorization = e.request.headers.authorization.split(' ')[0] + ' ...'

  return e
}

const run = async (reqOptions, { destination, jwt, kind, resolvedTarget }) => {
  const dest = typeof destination === 'string' ? { destinationName: destination, jwt } : destination

  let response
  try {
    response = await _executeHttpRequest(dest, reqOptions)
  } catch (e) {
    // > axios received status >= 400 -> gateway error
    e.message = e.message ? 'Error during request to remote service: ' + e.message : 'Request to remote service failed.'

    // log useful stuff from e
    LOG._warn && LOG.warn(_prepareErrorForLogging(e, reqOptions))

    // throw small, sanatized error
    throw Object.assign(new Error(e.message), { code: 502 })
  }

  return kind === 'odata' ? _getPurgedOdataResponse(response.data, resolvedTarget, reqOptions.headers) : response.data
}

const getJwt = req => {
  const headers = req && req.context && req.context.headers
  if (headers && headers.authorization) {
    const token = headers.authorization.match(/^bearer (.+)/i)
    if (token) {
      return token[1]
    }
  }
  return null
}

const _cqnToReqOptions = (query, target, kind) => {
  const queryObject = generateQuery(query, target, kind)
  return {
    method: queryObject.method,
    url: encodeURI(
      queryObject.path
        // ugly workaround for Okra not allowing spaces in ( x eq 1 )
        .replace(/\( /g, '(')
        .replace(/ \)/g, ')')
    ),
    data: queryObject.body
  }
}

const _stringToReqOptions = (query, data) => {
  const cleanQuery = query.trim()
  const blankIndex = cleanQuery.substring(0, 8).indexOf(' ')
  const reqOptions = {
    method: cleanQuery.substring(0, blankIndex).toUpperCase(),
    url: encodeURI(formatPath(cleanQuery.substring(blankIndex, cleanQuery.length).trim()))
  }
  if (data && Object.keys(data).length) reqOptions.data = data
  return reqOptions
}

const _pathToReqOptions = (method, path, data) => {
  let url = path
  if (!url.startsWith('/')) {
    // extract entity name and instance identifier (either in "()" or after "/") from fully qualified path
    const parts = path.match(/([\w.]*)([\W.]*)(.*)/)
    if (!parts) url = '/' + path.match(/\w*$/)[0]
    else url = '/' + parts[1].match(/\w*$/)[0] + parts[2] + parts[3]

    // normalize in case parts[2] already starts with /
    url = url.replace(/^\/\//, '/')
  }
  const reqOptions = { method, url }
  if (data && Object.keys(data).length) reqOptions.data = data
  return reqOptions
}

const getReqOptions = (req, query, service, resolvedTarget) => {
  const reqOptions =
    typeof query === 'object'
      ? _cqnToReqOptions(query, resolvedTarget, service.kind)
      : typeof query === 'string'
      ? _stringToReqOptions(query, req.data)
      : _pathToReqOptions(req.method, req.path, req.data)

  reqOptions.headers = { accept: 'application/json,text/plain' }
  reqOptions.timeout = service.requestTimeout

  if (reqOptions.data && Object.keys(reqOptions.data).length) {
    reqOptions.headers['content-type'] = 'application/json'
    reqOptions.headers['content-length'] = Buffer.byteLength(JSON.stringify(reqOptions.data))
  }

  reqOptions.url = formatPath(reqOptions.url)

  if (service.path) reqOptions.url = `${encodeURI(service.path)}${reqOptions.url}`

  return reqOptions
}

// REVISIT: todo renaming for expanded entities
// REVISIT: todo renaming for deep operations
const postProcess = (query, result) => {
  if (query.SELECT) {
    handleAliasInResult(query, result)
    return typeof query === 'object' && query.SELECT.one && Array.isArray(result) ? result[0] : result
  }
  if (query.DELETE) return result
  let transition
  if (query.INSERT) transition = query.INSERT._transitions[query.INSERT._transitions.length - 1]
  if (query.UPDATE) transition = query.UPDATE._transitions[query.UPDATE._transitions.length - 1]
  return revertData(result, transition)
}

const getAdditionalOptions = (req, destination, kind, resolvedTarget) => {
  const jwt = getJwt(req)
  const additionalOptions = { destination, kind, resolvedTarget }
  if (jwt) additionalOptions.jwt = jwt
  return additionalOptions
}

const getDestination = (model, datasource, options) =>
  createDestinationObject(findServiceName(model, datasource, options), options.credentials)

module.exports = {
  getKind,
  run,
  getReqOptions,
  postProcess,
  getDestination,
  getAdditionalOptions
}
