const { foreignKeyPropagations } = require('./foreignKeyPropagations')
const { _structPrefix } = require('./foreignKeyPropagations')

const _toRef = (alias, column) => {
  if (Array.isArray(column)) column = column.join('_')
  return { ref: alias ? [alias, column] : [column] }
}

const _adaptOncondElements = (onCond, associationName, selectAlias, joinAlias) => {
  return onCond.map(el => {
    if (el.ref) {
      if (el.ref[0] === associationName.join('_') && el.ref[1]) {
        return _toRef(selectAlias, el.ref.slice(1))
      } else {
        return _toRef(joinAlias, el.ref.slice(0))
      }
    } else {
      return el
    }
  })
}

const _args = (csnElement, options) => {
  const { associationNames, csn, aliases } = options
  const onCond = csnElement.on

  if (!onCond || !onCond.length) {
    return []
  }

  if (onCond.length < 3) {
    return onCond
  }

  if ((onCond[0].ref && onCond[0].ref[0] === '$self') || (onCond[2].ref && onCond[2].ref[0] === '$self')) {
    const target =
      onCond[0].ref[0] === '$self' ? onCond[2].ref[onCond[2].ref.length - 1] : onCond[0].ref[onCond[0].ref.length - 1]

    const oc = getOnCondNew(csn.definitions[csnElement.target].elements[target], {
      associationNames: target,
      csn,
      // revert join and select aliases because of backlink
      aliases: { select: aliases.join, join: aliases.select }
    })

    if (onCond.some(ele => ele === 'and')) {
      const and = _adaptOncondElements(
        onCond.slice(onCond.findIndex(ele => ele === 'and') + 1),
        associationNames,
        aliases.select,
        aliases.join
      )
      oc.push('and', ...and)
    }

    return oc
  }

  return _adaptOncondElements(onCond, associationNames, aliases.select, aliases.join)
}

const _foreignToOn = (csnElement, options) => {
  const { aliases, resolveView } = options
  const on = []
  const foreignKeys = foreignKeyPropagations(csnElement, true, resolveView)

  // for external services, there might be no foreign keys
  if (foreignKeys) {
    for (const key of foreignKeys) {
      if (on.length !== 0) {
        on.push('and')
      }

      // TODO static values possible here?

      on.push(
        _toRef(aliases.select, key.childFieldName),
        '=',
        _toRef(aliases.join, _structPrefix(csnElement) + key.parentFieldName)
      )
    }
  }

  return on
}

/**
 * @typedef {object} ONConditionAliases
 * @property {string} select
 * @property {string} join
 */

/**
 * @typedef {object} ONConditionOptions
 * @property {string | Array} [associationNames]
 * @property {object} [csn]
 * @property {ONConditionAliases} [aliases]
 * @property {boolean} [resolveView=true]
 */

/**
 * Gets the <code>ON</code> conditions in CQN format based on the CSN.
 *
 * @param {object} csnElement
 * @param {ONConditionOptions} [options]
 * @returns {Array}
 * @private
 */
function getOnCondNew(csnElement, options) {
  const defaultOptions = {
    aliases: {},
    resolveView: true
  }
  options = { ...defaultOptions, ...options }
  const { associationNames } = options

  if (!Array.isArray(associationNames)) {
    options.associationNames = [associationNames]
  }

  if (csnElement.keys) {
    return _foreignToOn(csnElement, options)
  }

  return _args(csnElement, options)
}

const getOnCond = (...args) => {
  return ['(', ...getOnCondNew(...args), ')']
}

module.exports = {
  getOnCond
}
