const {fs} = require('@sap/cds-foss')
const path = require('path')
const _cds = require('./cds')
const { BUILD_TASK_USE_PREFIX, BUILD_TASK_NPM_SCOPE } = require("./constants")

const DEBUG = process.env.DEBUG

class BuildTaskHandlerFactory {
    constructor(logger, cds) {
        this._logger = logger || global.console
        this._cds = cds ? cds : _cds
    }
    get cds() {
        return this._cds
    }
    get env() {
        return this._cds.env
    }
    get logger() {
        return this._logger
    }

    /**
     * Create a BuildTaskHandler instance for the given build task.
     * The implementation is loaded based on the build task's 'for' or 'use' option.
     * @param {*} task
     * @param {*} buildOptions
     */
    createHandler(task, buildOptions) {
        const BuildTaskHandler = this.loadHandler(task)
        const resolvedTask = this.resolveTask(task, buildOptions)
        if (DEBUG) {
            this.logger.log(`[cds] - loaded BuildTaskHandler [${resolvedTask.use}]`)
        }
        const handler = new BuildTaskHandler()
        handler.task = resolvedTask
        handler.buildOptions = buildOptions
        handler.cds = this.cds
        handler.logger = this.logger
        if (DEBUG) {
            this.logger.log(`[cds] - created BuildTaskHandler [${resolvedTask.use}]`)
        }
        return handler
    }

    /**
     * Loads the build task handler implementation for the given build task.
     * 'for' defines an alias for built-in handlers like 'hana', 'java-cf', 'node-cf', 'fiori' or 'mtx'.
     * 'use' defines the fully qualified module name of external build task handler implemenations.
     * @param {*} task
     */
    loadHandler(task) {
        const modulePath = BuildTaskHandlerFactory._getModulePathFromTask(task)
        try {
            return module.parent.require(modulePath)
        }
        catch (e) {
            throw new Error(`Build task could not be resolved - module [${modulePath}] cannot be loaded:\n`+e)
        }
    }

    /**
     * Resolves the given build task based on the project root folder.<br>
     * The task is validated in order to ensure that 'src' refers to a valid folder and 'for' or 'use' reference can be required.
     * @param {*} task
     * @param {*} buildOptions
     */
    resolveTask(task, buildOptions) {
        // first validate handler implementation
        this.loadHandler(task)

        // second valdiate src path
        const resolvedTask = JSON.parse(JSON.stringify(task))
        if (!resolvedTask.use) {
            resolvedTask.use = BuildTaskHandlerFactory._getUseValueFromTask(resolvedTask)
        }
        if (!resolvedTask.for) {
            resolvedTask.for = BuildTaskHandlerFactory._getForValueFromTask(resolvedTask)
        }
        try {
            // resolving sym-links, but be careful as realpathSync is throwing exception if directory does not exist
            resolvedTask.src = fs.realpathSync(path.resolve(buildOptions.root, task.src))
        } catch (e) {
            throw new Error(`Build task [${resolvedTask.use}] could not be resolved - folder src [${path.resolve(buildOptions.root, task.src)}] does not exist`)
        }
        resolvedTask.dest = path.resolve(buildOptions.target, task.dest || task.src)
        return resolvedTask
    }

    static _getModulePathFromTask(task) {
        let modulePath = BuildTaskHandlerFactory._getUseValueFromTask(task)
        if (!modulePath) {
            throw new Error(`Invalid build task definition - value of property 'for' or 'use' is missing.`)
        }
        if (!modulePath.startsWith(BUILD_TASK_NPM_SCOPE) && !modulePath.startsWith("..")) { // the latter is for testing purposes only
            throw new Error(`External build task implementations are only allowed for npm scope @sap - package name [${modulePath}]`)
        }
        if (modulePath.startsWith(BUILD_TASK_USE_PREFIX)) {
            // built-in handler
            modulePath = "./" + modulePath.substring(BUILD_TASK_USE_PREFIX.length)
        }
        return modulePath
    }

    static _getForValueFromTask(task) {
        if (task.for) {
            return task.for
        }
        return task.use && task.use.startsWith(BUILD_TASK_USE_PREFIX) ? task.use.substring(BUILD_TASK_USE_PREFIX.length) : null
    }

    static _getUseValueFromTask(task) {
        if (task.use) {
            return task.use
        }
        return task.for ? BUILD_TASK_USE_PREFIX + task.for : null
    }
}
module.exports = BuildTaskHandlerFactory
