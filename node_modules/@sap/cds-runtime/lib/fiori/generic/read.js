const cds = require('../../cds')
const { SELECT } = cds.ql

const { DRAFT_COLUMNS, DRAFT_COLUMNS_MAP } = require('../../common/constants/draft')
const {
  adaptStreamCQN,
  addColumnAlias,
  draftIsLocked,
  ensureDraftsSuffix,
  ensureNoDraftsSuffix,
  ensureUnlocalized,
  getEnrichedCQN,
  removeAnnotationWhere,
  removeDraftUUID,
  replaceRefWithDraft,
  hasKeyInWhere
} = require('../utils/handler')
const { deleteCondition, readAndDeleteKeywords, removeIsActiveEntityRecursively } = require('../utils/where')
const { getColumns } = require('../../cds-services/services/utils/columns')
const cqn2cqn4sql = require('../../common/utils/cqn2cqn4sql')
const { removeVirtuals, postProcessVirtuals } = require('../../db/generic/virtual')

// REVISIT: remove everywhere
const SYMBOL_FROM_ANNOTATION = Symbol.for('sap.cds.FROM_ANNOTATION')

const _isTrue = val => val === true || val === 'true'

const _isFalse = val => val === false || val === 'false'

const _inProcessByUserWhere = userId => [{ ref: ['filterAdmin', 'InProcessByUser'] }, '=', { val: userId }]

const _getTableName = (
  {
    target: { name },
    query: {
      SELECT: { from }
    }
  },
  isDraft = false
) => {
  const table = isDraft ? ensureDraftsSuffix(name) : ensureNoDraftsSuffix(name)
  const as = from.args ? from.args[0].as : from.as
  if (as) {
    return {
      table: {
        ref: [table],
        as: as
      },
      name: as
    }
  }

  return {
    table: {
      ref: [table]
    },
    name: table
  }
}

const _getTargetKeys = ({ target }) => {
  return Object.keys(target.keys).filter(key => key !== 'IsActiveEntity')
}

const DRAFT_COLUMNS_CASTED = [
  {
    ref: ['IsActiveEntity'],
    cast: { type: 'cds.Boolean' }
  },
  {
    ref: ['HasActiveEntity'],
    cast: { type: 'cds.Boolean' }
  },
  {
    ref: ['HasDraftEntity'],
    cast: { type: 'cds.Boolean' }
  }
]

// default draft values for active entities
const _getDefaultDraftProperties = ({ hasDraft, isActive = true, withDraftUUID = true }) => {
  const columns = [
    { val: isActive, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } },
    { val: false, as: 'HasActiveEntity', cast: { type: 'cds.Boolean' } }
  ]

  if (hasDraft !== null) {
    columns.push({
      val: Boolean(hasDraft),
      as: 'HasDraftEntity',
      cast: { type: 'cds.Boolean' }
    })
  }

  if (withDraftUUID) {
    columns.push(
      isActive
        ? { val: null, as: 'DraftAdministrativeData_DraftUUID' }
        : { ref: ['DraftAdministrativeData_DraftUUID'], as: 'DraftAdministrativeData_DraftUUID' }
    )
  }

  return columns
}

// draft values for active entities with calculated hasDraft property
const _getDraftPropertiesDetermineDraft = (req, where, tableName, calcDraftUUID = false) => {
  const { table } = _getTableName(req, true)

  tableName = tableName || table

  const hasDraftQuery = SELECT.from(tableName, [{ val: 1 }])
  if (where && where.length > 0) {
    hasDraftQuery.where(where)
    removeAnnotationWhere(hasDraftQuery.SELECT.where)
  }

  let draftUUIDColumn
  if (calcDraftUUID) {
    draftUUIDColumn = SELECT.from(tableName, ['DraftAdministrativeData_DraftUUID'])
    if (where && where.length > 0) {
      draftUUIDColumn.where(where)
    }
  } else {
    draftUUIDColumn = { val: null, as: 'DraftAdministrativeData_DraftUUID' }
  }

  const xpr = {
    xpr: ['case', 'when', hasDraftQuery, 'IS NOT NULL', 'then', 'true', 'else', 'false', 'end'],
    as: 'HasDraftEntity',
    cast: { type: 'cds.Boolean' }
  }

  hasDraftQuery.as = 'HasDraftEntity'
  hasDraftQuery.cast = { type: 'cds.Boolean' }

  return [
    { val: true, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } },
    { val: false, as: 'HasActiveEntity', cast: { type: 'cds.Boolean' } },
    xpr,
    draftUUIDColumn
  ]
}

function _copyCQNPartial(partial) {
  if (partial.SELECT && partial.SELECT.where) {
    const newPartial = Object.assign({}, partial)
    const newSELECT = Object.assign({}, partial.SELECT)
    newSELECT.from = _copyCQNPartial(partial.SELECT.from)
    newPartial.SELECT = newSELECT
    if (partial.SELECT.columns) newPartial.SELECT.columns = _copyArray(partial.SELECT.columns)
    if (partial.SELECT.where) newPartial.SELECT.where = _copyArray(partial.SELECT.where)
    return newPartial
  }

  return partial.ref ? Object.assign({}, partial, { ref: _copyArray(partial.ref) }) : Object.assign({}, partial)
}

function _copyArray(array) {
  const copy = array.map(entry => {
    return typeof entry === 'object' && !(entry instanceof String) ? _copyCQNPartial(entry) : entry
  })
  if (array[SYMBOL_FROM_ANNOTATION] === true) {
    copy[SYMBOL_FROM_ANNOTATION] = true
  }
  return copy
}

const _whereContainsKeys = (req, whereDraft) => {
  const keys = _getTargetKeys(req)
  if (whereDraft.length < keys.length * 4 - 1) {
    return false
  }

  let i = 0
  let keyCount = 0
  while (i < whereDraft.length) {
    const element = whereDraft[i]
    const op = whereDraft[i + 1]
    if (element.ref && keys.some(x => x === element.ref[element.ref.length - 1]) && op === '=') {
      // op is EQ by keys
      i = i + 4
      keyCount++
      continue
    }

    i++
  }

  return keyCount === keys.length
}

const _isValidActive = (isActiveEntity, req, whereDraft) => {
  return isActiveEntity.op === '=' && _isTrue(isActiveEntity.value.val) && _whereContainsKeys(req, whereDraft)
}

const _isValidDraftOfWhichIAmOwner = isActiveEntity => {
  return isActiveEntity.op === '=' && _isFalse(isActiveEntity.value.val)
}

const _isValidActiveWithoutDraft = (isActiveEntity, hasDraftEntity) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    hasDraftEntity.op === '=' &&
    _isFalse(hasDraftEntity.value.val)
  )
}

const _isValidWithDraftLocked = (isActiveEntity, siblingIsActive, draftInProcessByUser) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null &&
    draftInProcessByUser.op === '!=' &&
    draftInProcessByUser.value.val === ''
  )
}

const _isValidWithDraftTimeout = (isActiveEntity, siblingIsActive, draftInProcessByUser) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null &&
    draftInProcessByUser.op === '=' &&
    draftInProcessByUser.value.val === ''
  )
}

const _isValidExcludeActiveDraftExists = (isActiveEntity, siblingIsActive) => {
  return (
    isActiveEntity.op === '=' &&
    _isFalse(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null
  )
}

const _filterDraftColumnsBySelected = (draftColumns, columns) => {
  const _findByAlias = (draftColumn, alias) => alias && draftColumn.as && alias === draftColumn.as
  const _findByRef = (draftColumn, ref) => ref && draftColumn.ref && ref === draftColumn.ref[draftColumn.ref.length - 1]
  // include draft-specific columns only if there is no SELECT.columns or if they are selected explicitly
  return (
    (!columns && draftColumns) ||
    draftColumns.filter(
      draftColumn =>
        (!draftColumn.ref && !draftColumn.as) ||
        columns.find(col => {
          const ref = col.ref && col.ref[col.ref.length - 1]
          return _findByRef(draftColumn, ref) || _findByAlias(draftColumn, ref) || _findByAlias(draftColumn, col.as)
        })
    )
  )
}

const _isOnlyCount = columns => columns.length === 1 && columns[0].as === 'counted'

const _getOuterMostColumns = (columnsFromRequest, additionalDraftColumns) => {
  if (_isOnlyCount(columnsFromRequest)) return columnsFromRequest

  // remove draft columns from columnsFromRequest (if present) to avoid duplicates
  const columns = [...columnsFromRequest.filter(ele => !ele.as || !DRAFT_COLUMNS_MAP[ele.as])]
  columns.push(...additionalDraftColumns)
  return columns
}

const _draftAdminTable = req => {
  const { table } = _getTableName(req)

  let cqn = SELECT.from(table)
  if (req.query.SELECT.columns) {
    cqn = cqn.columns(...req.query.SELECT.columns)
  }

  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, req.query.SELECT.where), scenario: 'DRAFT_ADMIN' }
}

const _allInactive = (req, columns, model) => {
  const table = {
    ref: [ensureDraftsSuffix(req.query.SELECT.from.ref[0])],
    as: req.query.SELECT.from.as || 'drafts'
  }

  const outerMostColumns = _getOuterMostColumns(
    addColumnAlias(columns, table.as),
    _getDefaultDraftProperties({ hasDraft: false, isActive: false, withDraftUUID: false })
  )

  // determine name of primary key to use in HasActiveEntity expression
  const pk = req.target['@assert.unique.locale']
    ? req.target['@assert.unique.locale'].map(o => o['=']).find(k => k !== 'locale')
    : Object.keys(req.target.keys).find(ele => ele !== 'IsActiveEntity')

  const xpr = {
    xpr: ['case', 'when', `active.${pk}`, 'IS NOT NULL', 'then', 'true', 'else', 'false', 'end'],
    as: 'HasActiveEntity',
    cast: { type: 'cds.Boolean' }
  }

  const ids = Object.keys(req.target.keys).filter(element => element !== 'IsActiveEntity')
  const isCount = columns.some(element => element.func === 'count')

  const cqn = SELECT.from(table)

  if (isCount) {
    cqn.columns(...outerMostColumns)
  } else {
    cqn.columns(...outerMostColumns.filter(o => o.as !== 'HasActiveEntity'), xpr)
    cqn.leftJoin(ensureNoDraftsSuffix(table.ref[0]) + ' as active').on(`${table.as}.${ids[0]} = active.${ids[0]}`)

    for (let i = 1; i < ids.length; i++) {
      // REVISIT: this is extremely expensive as it repeatedly invokes the compiler's cds.parse.expr -> better extend plain CQN yourself here
      cqn.and(`${table.as}.${ids[i]} = active.${ids[i]}`)
    }
  }

  cqn.where(req.query.SELECT.where)
  removeAnnotationWhere(cqn.SELECT.where)

  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, []), scenario: 'ALL_INACTIVE' }
}

const _setRefAlias = (ref, as) => {
  if (ref && ref[0] !== as) {
    ref.unshift(as)
  }
}

const _buildWhere = (where, table) => {
  for (const entry of where) {
    if (entry.ref) {
      _setRefAlias(entry.ref, table.as)
    } else if (entry.func && entry.args) {
      _buildWhere(entry.args, table)
    } else if (entry.list) {
      _buildWhere(entry.list, table)
    }
  }
}

const _buildOrderBy = (query, columns, table) => {
  for (const entry of query.SELECT.orderBy || []) {
    // detect if calculated value
    if (entry.ref && columns.some(c => c.as === entry.ref[entry.ref.length - 1])) {
      // remove table alias if present
      if (entry.ref[0] === table.as) {
        entry.ref.splice(0, 1)
      }
    } else if (table.as && entry.ref[0] !== table.as) {
      // if regular column and no alias present, add it
      entry.ref.unshift(table.as)
    }
  }
}

const _allActive = (req, columns) => {
  const { table } = _getTableName(req)
  if (!table.as) {
    table.as = 'active'
  }

  const outerMostColumns = _getOuterMostColumns(
    addColumnAlias(columns, table.as),
    _getDefaultDraftProperties({ hasDraft: null })
  )

  const ids = Object.keys(req.target.keys).filter(element => element !== 'IsActiveEntity')
  const isCount = columns.some(element => element.func === 'count')

  const xpr = {
    xpr: [
      'case',
      'when',
      'drafts.DraftAdministrativeData_DraftUUID',
      'IS NOT NULL',
      'then',
      'true',
      'else',
      'false',
      'end'
    ],
    as: 'HasDraftEntity',
    cast: { type: 'cds.Boolean' }
  }

  const cqn = SELECT.from(table)

  if (isCount) {
    cqn.columns(..._filterDraftColumnsBySelected(outerMostColumns, req.query.SELECT.columns))
  } else {
    cqn.columns(..._filterDraftColumnsBySelected([...outerMostColumns, xpr], req.query.SELECT.columns))
    cqn.leftJoin(ensureDraftsSuffix(table.ref[0]) + ' as drafts').on(`${table.as}.${ids[0]} = drafts.${ids[0]}`)

    for (let i = 1; i < ids.length; i++) {
      // REVISIT: this is extremely expensive as it repeatedly invokes the compiler's cds.parse.expr -> better extend plain CQN yourself here
      cqn.and(`${table.as}.${ids[i]} = drafts.${ids[i]}`)
    }
  }

  if (req.query.SELECT.where) {
    _buildWhere(req.query.SELECT.where, table)
  }
  _buildOrderBy(req.query, cqn.SELECT.columns, table)

  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, req.query.SELECT.where, 'active'), scenario: 'ALL_ACTIVE' }
}

const _active = (req, draftWhere, columns) => {
  const { table } = _getTableName(req)

  const outerMostColumns = _getOuterMostColumns(columns, _getDraftPropertiesDetermineDraft(req, draftWhere))

  const cqn = SELECT.from(table).columns(...outerMostColumns)

  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, draftWhere), scenario: 'ACTIVE' }
}

const _activeWithoutDraft = (req, draftWhere, columns) => {
  const { table } = _getTableName(req, true)
  const draftName = table.ref[0]
  const active = _getTableName(req)
  const keys = _getTargetKeys(req)

  let subSelect = SELECT.from(draftName).columns(...keys)
  subSelect = keys.reduce(
    (select, key) =>
      subSelect.where([
        { ref: [active.name, key] },
        '=',
        {
          ref: [draftName, key]
        }
      ]),
    subSelect
  )

  const outerMostColumns = _getOuterMostColumns(columns, _getDefaultDraftProperties({ hasDraft: false }))

  const cqn = SELECT.from(active.table)
    .columns(...outerMostColumns)
    .where(['not exists', subSelect])

  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, draftWhere), scenario: 'ACTIVE_WITHOUT_DRAFT' }
}

const _draftOfWhichIAmOwner = (req, draftWhere, columns) => {
  const { table, name } = _getTableName(req, true)

  const outerMostColumns = _getOuterMostColumns(addColumnAlias(columns, name), DRAFT_COLUMNS_CASTED)

  const cqn = SELECT.from(table)
    .columns(...outerMostColumns)
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on([
      { ref: [name, 'DraftAdministrativeData_DraftUUID'] },
      '=',
      {
        ref: ['filterAdmin', 'DraftUUID']
      }
    ])
    .where(_inProcessByUserWhere(req.user.id))

  removeAnnotationWhere(draftWhere)

  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, draftWhere), scenario: 'DRAFT_WHICH_OWNER' }
}

const _activeWithDraftInProcess = (req, draftWhere, columns, isLocked) => {
  const draft = _getTableName(req, true)
  const draftName = draft.table.ref[0]
  const active = _getTableName(req)
  const keys = _getTargetKeys(req)
  const draftColumns = _getDefaultDraftProperties({ hasDraft: true })

  let subSelect = SELECT.from(draftName)
    .columns(...keys)
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on([
      { ref: [draftName, 'DraftAdministrativeData_DraftUUID'] },
      '=',
      {
        ref: ['filterAdmin', 'DraftUUID']
      }
    ])

  const DRAFT_CANCEL_TIMEOUT_IN_SEC = ((cds.env.drafts && cds.env.drafts.cancellationTimeout) || 15) * 60

  subSelect = subSelect.where([
    { ref: ['filterAdmin', 'InProcessByUser'] },
    '!=',
    { val: req.user.id },
    'and',
    { ref: ['filterAdmin', 'InProcessByUser'] },
    'is not null',
    'and',
    {
      func: 'seconds_between',
      args: [{ ref: ['filterAdmin', 'LastChangeDateTime'] }, { ref: ['CURRENT_TIMESTAMP'] }]
    },
    isLocked ? '<' : '>',
    { val: DRAFT_CANCEL_TIMEOUT_IN_SEC }
  ])

  subSelect = keys.reduce(
    (select, key) => subSelect.where([{ ref: [active.name, key] }, '=', { ref: [draftName, key] }]),
    subSelect
  )

  const outerMostColumns = _getOuterMostColumns(columns, draftColumns)

  const cqn = SELECT.from(active.table).columns(outerMostColumns).where(['exists', subSelect])

  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, draftWhere), scenario: 'DRAFT_IN_PROCESS' }
}

const _alignAliasForUnion = (table, as, select) => {
  if (!as || !select.SELECT.where) {
    return select
  }

  for (const entry of select.SELECT.where) {
    if (entry.ref && entry.ref[0] === table) {
      entry.ref[0] = as
    }
  }

  return select
}

const _isKeyElement = (element, keys) => element.ref && keys.includes(element.ref[element.ref.length - 1])
const _valExists = (i, length, where) => i < length - 2 && where[i + 2].val

const _findKeysInWhereAndAddToResult = (where, keys, result) => {
  for (let i = 0, length = where.length; i < length; i++) {
    const element = where[i]
    if (_isKeyElement(element, keys) && _valExists(i, length, where)) {
      result[element.ref[element.ref.length - 1]] = where[i + 2].val
      i = i + 2
    }
  }
}

const _findKeysInQuery = (query, keys) => {
  const result = {}
  if (query.SELECT && query.SELECT.where) {
    const indexExists = query.SELECT.where.indexOf('exists')
    if (indexExists !== -1) {
      return _findKeysInQuery(query.SELECT.where[indexExists + 1], keys)
    }

    _findKeysInWhereAndAddToResult(query.SELECT.where, keys, result)
  }
  return result
}

const _isFiltered = where => {
  return where.some(element => {
    return !(element in ['(', ')']) && element[SYMBOL_FROM_ANNOTATION] !== true
  })
}

const _isDraftField = element => element.ref && element.ref.length > 1 && element.ref[0] === 'DraftAdministrativeData'

const _functionContainsDraftField = obj =>
  typeof obj === 'object' &&
  obj.func &&
  obj.args.some(arg => {
    return _isDraftField(arg) || _functionContainsDraftField(arg)
  })

const _isLogicalFunction = (where, index) => {
  const borders = ['(', ')', 'and', 'or', undefined]

  return borders.includes(where[index - 1]) && borders.includes(where[index + 1])
}

const _getWhereForActive = where => {
  const activeWhere = []
  for (let i = 0; i < where.length; i++) {
    if (_isDraftField(where[i])) {
      activeWhere.push({ val: null })
    } else if (_functionContainsDraftField(where[i])) {
      if (_isLogicalFunction(where, i)) {
        activeWhere.push({ val: 1 }, '=', { val: 2 })
      } else {
        activeWhere.push({ val: null })
      }
    } else {
      activeWhere.push(where[i])
    }
  }

  for (let i = 0; i < activeWhere.length; i++) {
    if (
      activeWhere[i].val === null &&
      activeWhere[i + 1] === '=' &&
      activeWhere[i + 2] &&
      activeWhere[i + 2].val === null
    ) {
      activeWhere[i] = { val: 1 }
      activeWhere[i + 2] = { val: 1 }
    }
  }

  return activeWhere
}

const _siblingEntity = (req, columns, model) => {
  const unlocalizedEntity = model.definitions[ensureUnlocalized(req.target.name)]
  const keys = _findKeysInQuery(req.query, Object.keys(unlocalizedEntity.keys))
  const isSiblingActive = !keys.IsActiveEntity

  const targetTable = isSiblingActive ? ensureNoDraftsSuffix(req.target.name) : ensureDraftsSuffix(req.target.name)
  const columnCqnPartial = columns.map(col => {
    const colName = col.ref ? col.ref[col.ref.length - 1] : col
    return { ref: ['target', colName], as: colName }
  })
  columnCqnPartial.push({ ref: ['draftAdmin', 'InProcessByUser'], as: 'draftAdmin_inProcessByUser' })
  const cqn = SELECT.from(`${targetTable} as target`).columns(...columnCqnPartial)

  if (isSiblingActive) {
    cqn
      .join(ensureDraftsSuffix(req.target.name), 'target_draft')
      .on(
        Object.keys(keys)
          .map(k => `target.${k} = target_draft.${k}`)
          .join(' AND ')
      )
      .join('DRAFT.DraftAdministrativeData', 'draftAdmin')
      .on('target_draft.DraftAdministrativeData_DraftUUID = draftAdmin.DraftUUID')
  } else {
    cqn
      .join('DRAFT.DraftAdministrativeData', 'draftAdmin')
      .on('target.DraftAdministrativeData_DraftUUID = draftAdmin.DraftUUID')
  }

  for (const key in keys) {
    if (key !== 'IsActiveEntity') cqn.where([{ ref: ['target', key] }, '=', { val: keys[key] }])
  }

  return { cqn, scenario: 'SIBLING_ENTITY', isSiblingActive: isSiblingActive }
}

const _getDraftDoc = (req, draftName, draftWhere) => {
  const refDraft = req.query.SELECT.from.as ? { ref: [draftName], as: req.query.SELECT.from.as } : draftName

  const draftDocs = getEnrichedCQN(
    SELECT.from(refDraft)
      .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
      .on([
        { ref: [req.query.SELECT.from.as || draftName, 'DraftAdministrativeData_DraftUUID'] },
        '=',
        {
          ref: ['filterAdmin', 'DraftUUID']
        }
      ])
      .where(_inProcessByUserWhere(req.user.id)),
    req.query.SELECT,
    draftWhere,
    undefined,
    false
  )

  return draftDocs
}

const _getOrderByEnrichedColumns = (orderBy, columns) => {
  const enrichedCol = []
  if (orderBy.length > 1) {
    const colNames = columns.map(el => el.ref[el.ref.length - 1])
    // REVISIT: GET Books?$select=title&$expand=NotBooks($select=pages)&$orderby=NotBooks/title - what's then?
    for (const el of orderBy) {
      if (!DRAFT_COLUMNS.includes(el.ref[el.ref.length - 1]) && !colNames.includes(el.ref[el.ref.length - 1])) {
        enrichedCol.push({ ref: [...el.ref] })
      }
    }
  }
  return enrichedCol
}

const _replaceDraftAlias = where => {
  where.forEach(element => {
    if (_isDraftField(element)) {
      element.ref[0] = 'filterAdmin'
    }

    if (typeof element === 'object' && element.func) {
      _replaceDraftAlias(element.args)
    }
  })
}

const _getUnionCQN = (req, draftName, columns, subSelect, draftWhere) => {
  const draftActiveWhere = _getWhereForActive(draftWhere)
  const activeDocs = getEnrichedCQN(SELECT.from(req.target), req.query.SELECT, draftActiveWhere, undefined, false)

  _replaceDraftAlias(draftWhere)
  const draftDocs = _getDraftDoc(req, draftName, draftWhere)
  removeAnnotationWhere(draftDocs.SELECT.where)

  const union = SELECT.from({ SET: { op: 'union', all: true, args: [draftDocs, activeDocs] } })
  if (req.query.SELECT.count) union.SELECT.count = true

  if (req.query.SELECT.from.as) {
    draftDocs.SELECT.from.as = req.query.SELECT.from.as
    activeDocs.SELECT.from.as = req.query.SELECT.from.as
  }

  if (_isOnlyCount(columns)) {
    draftDocs.columns(...columns)
    activeDocs
      .columns(...columns)
      .where([
        'not exists',
        _alignAliasForUnion(ensureNoDraftsSuffix(req.target.name), req.query.SELECT.from.as, subSelect)
      ])

    return union.columns({ func: 'sum', args: [{ ref: ['counted'] }], as: 'counted' })
  }

  const enrichedColumns = _getOrderByEnrichedColumns(req.query.SELECT.orderBy, columns)

  draftDocs.columns(
    ...addColumnAlias([...columns, ...enrichedColumns], req.query.SELECT.from.as || draftName),
    ..._filterDraftColumnsBySelected(DRAFT_COLUMNS_CASTED, req.query.SELECT.columns),
    'DraftAdministrativeData_DraftUUID'
  )

  const activeName = activeDocs.SELECT.from.as || (activeDocs.SELECT.from.ref && activeDocs.SELECT.from.ref[0])

  const hasDraftWhere = []
  for (const key of _getTargetKeys(req)) {
    hasDraftWhere.push({ ref: [activeName, key] }, '=', { ref: [draftName, key] })
  }

  activeDocs
    .columns(
      ...columns,
      ...enrichedColumns,
      ..._filterDraftColumnsBySelected(
        _getDraftPropertiesDetermineDraft(req, hasDraftWhere, ensureDraftsSuffix(req.target.name), true),
        req.query.SELECT.columns
      )
    )
    .where([
      'not exists',
      _alignAliasForUnion(ensureNoDraftsSuffix(req.target.name), req.query.SELECT.from.as, subSelect)
    ])

  // groupBy, orderBy and limit do not support partial CQNs
  if (req.query.SELECT.groupBy) {
    union.SELECT.groupBy = req.query.SELECT.groupBy
  }

  if (req.query.SELECT.orderBy) {
    union.SELECT.orderBy = req.query.SELECT.orderBy
  }

  if (req.query.SELECT.limit) {
    union.SELECT.limit = req.query.SELECT.limit
  }

  return union
    .columns(...columns)
    .columns(..._filterDraftColumnsBySelected(DRAFT_COLUMNS_CASTED, req.query.SELECT.columns))
}

const _excludeActiveDraftExists = (req, draftWhere, columns) => {
  const { table, name } = _getTableName(req, true)
  const draftName = table.ref[0]

  const subSelect = SELECT.from(draftName, [1])
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on([
      { ref: [draftName, 'DraftAdministrativeData_DraftUUID'] },
      '=',
      {
        ref: ['filterAdmin', 'DraftUUID']
      }
    ])
    .where(_inProcessByUserWhere(req.user.id))

  for (const key of _getTargetKeys(req)) {
    subSelect.where([{ ref: [ensureNoDraftsSuffix(req.target.name), key] }, '=', { ref: [draftName, key] }])
  }

  draftWhere = removeIsActiveEntityRecursively(draftWhere)
  const cqn = _getUnionCQN(req, draftName, columns, subSelect, draftWhere)
  cqn.SELECT.from.as = name

  if (cqn.SELECT.orderBy) {
    for (const entry of cqn.SELECT.orderBy || []) {
      if (entry.ref.length > 1 && entry.ref[0] !== name) {
        entry.ref[0] = name
      }
    }
  }

  return { cqn: cqn, scenario: 'UNION' }
}

const _readDraftParameters = where => {
  const obj = {
    isActiveEntity: readAndDeleteKeywords(['IsActiveEntity'], where),
    hasDraftEntity: readAndDeleteKeywords(['HasDraftEntity'], where),
    siblingIsActive: readAndDeleteKeywords(['SiblingEntity', 'IsActiveEntity'], where),
    draftInProcessByUser: readAndDeleteKeywords(['DraftAdministrativeData', 'InProcessByUser'], where)
  }

  // remove "DraftAdministrativeData/InProcessByUser ne null" from request if necessary
  readAndDeleteKeywords(['DraftAdministrativeData', 'InProcessByUser'], where)

  return obj
}

const _validatedActiveWithoutDraft = (req, draftWhere, draftParameters, columns) =>
  _isValidActiveWithoutDraft(draftParameters.isActiveEntity, draftParameters.hasDraftEntity) &&
  _activeWithoutDraft(req, draftWhere, columns)

const _validatedWithSiblingInProcess = (req, draftWhere, draftParameters, columns) => {
  const { isActiveEntity, siblingIsActive, draftInProcessByUser } = draftParameters
  if (
    !draftInProcessByUser &&
    _isValidExcludeActiveDraftExists(draftParameters.isActiveEntity, draftParameters.siblingIsActive)
  )
    return _excludeActiveDraftExists(req, draftWhere, columns)
  if (
    draftInProcessByUser.op === '!=' &&
    _isValidWithDraftLocked(isActiveEntity, siblingIsActive, draftInProcessByUser)
  ) {
    return _activeWithDraftInProcess(req, draftWhere, columns, req.user.id)
  } else if (_isValidWithDraftTimeout(isActiveEntity, siblingIsActive, draftInProcessByUser)) {
    return _activeWithDraftInProcess(req, draftWhere, columns, null)
  }
}

const _validatedActive = (req, draftWhere, draftParameters, columns) =>
  _isValidActive(draftParameters.isActiveEntity, req, draftWhere) && _active(req, draftWhere, columns)

const _validatedDraftOfWhichIAmOwner = (req, draftWhere, draftParameters, columns) =>
  _isValidDraftOfWhichIAmOwner(draftParameters.isActiveEntity) && _draftOfWhichIAmOwner(req, draftWhere, columns)

const _draftInSubSelect = where => {
  return where.some(({ SELECT }) => {
    if (SELECT && SELECT.where) {
      const isActiveEntity = readAndDeleteKeywords(['IsActiveEntity'], SELECT.where, false)
      if (isActiveEntity) {
        return _isFalse(isActiveEntity.value.val)
      }

      return _draftInSubSelect(SELECT.where)
    }

    return false
  })
}

const _generateCQN = (reqOriginal, req, columns, serviceName, model) => {
  // REVISIT: get rid of getUrlObject
  if (req.getUrlObject && req.getUrlObject().path.endsWith('SiblingEntity')) {
    return _siblingEntity(req, columns, model)
  }

  if (
    req.target.query &&
    req.target.query._target &&
    req.target.query._target.name === 'DRAFT.DraftAdministrativeData'
  ) {
    return _draftAdminTable(req)
  }

  if (!req.query.SELECT.where || !_isFiltered(req.query.SELECT.where)) {
    return _allActive(req, columns)
  }

  const draftParameters = _readDraftParameters(req.query.SELECT.where)

  if (
    draftParameters.isActiveEntity &&
    _isTrue(draftParameters.isActiveEntity.value.val) &&
    !draftParameters.siblingIsActive &&
    !draftParameters.hasDraftEntity &&
    !hasKeyInWhere(reqOriginal.query.SELECT.from.ref[0].where, model.definitions[req.query.SELECT.from.ref[0]])
  ) {
    return _allActive(req, columns)
  }

  if (!draftParameters.isActiveEntity) {
    if (_draftInSubSelect(req.query.SELECT.where)) {
      return _allInactive(req, columns, model)
    }
    return _allActive(req, columns)
  }

  if (draftParameters.hasDraftEntity) {
    return _validatedActiveWithoutDraft(req, req.query.SELECT.where, draftParameters, columns)
  }

  if (draftParameters.siblingIsActive) {
    return _validatedWithSiblingInProcess(req, req.query.SELECT.where, draftParameters, columns)
  }

  return _isTrue(draftParameters.isActiveEntity.value.val)
    ? _validatedActive(req, req.query.SELECT.where, draftParameters, columns)
    : _validatedDraftOfWhichIAmOwner(req, req.query.SELECT.where, draftParameters, columns)
}

const _getColumns = ({ query: { SELECT } }, model) => {
  return SELECT.columns
    ? SELECT.columns.filter(
        col =>
          (col.ref && !DRAFT_COLUMNS.includes(col.ref[col.ref.length - 1])) ||
          (!col.ref && !DRAFT_COLUMNS.includes(col))
      )
    : getColumns(model.definitions[ensureNoDraftsSuffix(SELECT.from.ref[0])], {
        onlyNames: true,
        removeIgnore: true,
        filterVirtual: true
      })
}

const _isIsActiveEntity = element =>
  element.ref &&
  (element.ref[0] === 'IsActiveEntity' || (element.ref.length > 1 && element.ref[1] === 'IsActiveEntity'))

const _adaptSubSelects = ({ SELECT: { from, where } }, scenario) => {
  if (!where) {
    return
  }

  let indexDel = -1

  if (scenario === 'ALL_INACTIVE') {
    replaceRefWithDraft(from.ref)
  }

  for (let i = 0, len = where.length; i < len; i++) {
    const element = where[i]

    if (_isIsActiveEntity(element) && len > i + 2) {
      if (scenario !== 'ALL_INACTIVE' && _isFalse(where[i + 2].val)) {
        replaceRefWithDraft(from.ref)
        // read from draft table because draft has draftUUID
      } else if (scenario === 'DRAFT_ADMIN' && !_isFalse(where[i + 2].val)) {
        replaceRefWithDraft(from.ref)
      }

      indexDel = i
    }

    if (element.SELECT) {
      _adaptSubSelects(element, scenario)
    }
  }

  if (indexDel !== -1) {
    deleteCondition(indexDel, where)
  }
}

const _calculateDraftAdminColumns = (result, user) => {
  if (
    Object.prototype.hasOwnProperty.call(result, 'DraftIsCreatedByMe') &&
    Object.prototype.hasOwnProperty.call(result, 'CreatedByUser')
  ) {
    result.DraftIsCreatedByMe = result.CreatedByUser === user
  }

  if (
    Object.prototype.hasOwnProperty.call(result, 'DraftIsProcessedByMe') &&
    Object.prototype.hasOwnProperty.call(result, 'InProcessByUser')
  ) {
    result.DraftIsProcessedByMe = result.InProcessByUser === user
  }
}

const _adaptDraftColumnsForSiblingEntity = (result, isSiblingActive) => {
  result.IsActiveEntity = isSiblingActive
  result.HasDraftEntity = isSiblingActive
  result.HasActiveEntity = !isSiblingActive
}

const _addAlias = (whereElement, aliases) => {
  if (whereElement.ref) {
    const table = whereElement.ref[0].replace(/\./g, '_')
    const alias = aliases.get(table)
    if (alias) {
      whereElement.ref.splice(0, 1, aliases.get(table))
    }
  }
}

const _collectAliases = (from, aliases) => {
  if (from) {
    if (from.ref && from.as) {
      // Actually table names in where annotations should be provided with '.' separator.
      // Normalization to '_' is done for the exceptional case if '_' is still used (based on db table names).
      aliases.set(from.ref[0].replace(/\./g, '_'), from.as)
    } else if (from.args) {
      from.args.forEach(arg => {
        _collectAliases(arg, aliases)
      })
    } else if (from.SET && from.SET.args) {
      from.SET.args.forEach(arg => {
        _collectAliases(arg, aliases)
      })
    }
  }
}

const _adaptAliasForSubSelect = (subselect, aliases) => {
  if (subselect.where) {
    for (const whereElement of subselect.where) {
      if (whereElement.ref) {
        _addAlias(whereElement, aliases)
      }

      if (whereElement.SELECT) {
        _adaptAliasForSubSelect(whereElement.SELECT, aliases)
      }
    }
  }
}

const _adaptAnnotationAliases = cqn => {
  const aliases = new Map()
  _collectAliases(cqn.SELECT.from, aliases)

  if (cqn.SELECT.where) {
    for (const whereElement of cqn.SELECT.where) {
      if (
        whereElement.SELECT &&
        whereElement.SELECT.from.ref &&
        whereElement.SELECT.from.ref[SYMBOL_FROM_ANNOTATION] === true
      ) {
        _adaptAliasForSubSelect(whereElement.SELECT, aliases)
      }
    }
  }
}

const calculateDraftTimeout = (scenario, result, deleteLastChangeDateTime) => {
  if (scenario === 'DRAFT_ADMIN') {
    if (!draftIsLocked(result[0].LastChangeDateTime)) {
      result[0].InProcessByUser = ''
    }
    if (deleteLastChangeDateTime) delete result[0].LastChangeDateTime

    return
  }

  // non empty result that and DraftAdministrativeData was expanded
  if (result.length && Object.prototype.hasOwnProperty.call(result[0], 'DraftAdministrativeData')) {
    result.forEach(row => {
      if (!row.DraftAdministrativeData) return
      if (Object.prototype.hasOwnProperty.call(row.DraftAdministrativeData, 'InProcessByUser')) {
        if (!draftIsLocked(row.DraftAdministrativeData.LastChangeDateTime)) {
          row.DraftAdministrativeData.InProcessByUser = ''
        }
      }
      if (deleteLastChangeDateTime) delete row.DraftAdministrativeData.LastChangeDateTime
    })
  }
}

const enhanceQueryForTimeoutIfNeeded = (scenario, columns = []) => {
  if (scenario !== 'DRAFT_ADMIN') {
    const draftAdmin = columns.find(col => col.ref && col.ref[col.ref.length - 1] === 'DraftAdministrativeData')
    columns = (draftAdmin && draftAdmin.expand) || []
  }
  const inProcessByUser = columns.find(col => col.ref[col.ref.length - 1] === 'InProcessByUser')
  const lastChangeDateTime = columns.find(col => col.ref[col.ref.length - 1] === 'LastChangeDateTime')
  if (inProcessByUser && !lastChangeDateTime) {
    columns.push({ ref: [...inProcessByUser.ref.slice(0, inProcessByUser.ref.length - 1), 'LastChangeDateTime'] })
    return true
  }
}

// REVISIT: HACK for sqlite support, union not yet properly supported in before handler on db
// remove once union is removed, should be part of before handler
const _getLocalizedEntity = (model, target, user) => {
  const prefix = 'localized'
  let localizedEntity
  if (user.locale === 'de' || user.locale === 'fr') {
    localizedEntity = model.definitions[`${prefix}.${user.locale}.${target.name}`]
  }
  return localizedEntity || model.definitions[`${prefix}.${target.name}`]
}

/**
 * Generic Handler for READ requests in the context of draft.
 *
 * @param req
 */
const _handler = async function (req) {
  // handle localized here as it was previously handled for req.target
  req.target = _getLocalizedEntity(this.model, req.target, req.user) || req.target
  if (req.query.SELECT.limit && req.query.SELECT.limit.rows && req.query.SELECT.limit.rows.val === 0) {
    return Promise.resolve([])
  }

  // REVISIT
  delete req.query._validationQuery

  // REVISIT DRAFT HANDLING: cqn2cqn4sql must not be called here
  const sqlQuery = cqn2cqn4sql(req.query, this.model)

  // do not clone with Object.assign as that would skip all non-enumerable properties
  const reqClone = { __proto__: req, query: _copyCQNPartial(sqlQuery) }

  if (req.query._streaming) {
    adaptStreamCQN(reqClone.query)
    reqClone.query._streaming = true
    return cds.tx(req).run(reqClone.query)
  }
  const virtuals = removeVirtuals(reqClone, this.model)
  const cqnScenario = _generateCQN(req, reqClone, _getColumns(reqClone, this.model), this.name, this.model)

  if (!cqnScenario) {
    req.reject(400)
    return
  }
  const enhacnedWithLastChangeDateTime = enhanceQueryForTimeoutIfNeeded(
    cqnScenario.scenario,
    cqnScenario.cqn.SELECT.columns
  )

  _adaptSubSelects(cqnScenario.cqn, cqnScenario.scenario)

  _adaptAnnotationAliases(cqnScenario.cqn)

  // unlocalize for db and after handlers as it was before
  req.target = this.model.definitions[ensureUnlocalized(req.target.name)]
  const result = await cds.tx(req).run(cqnScenario.cqn)

  const resultAsArray = Array.isArray(result) ? result : result ? [result] : []

  removeDraftUUID(resultAsArray)

  if (cqnScenario.scenario === 'DRAFT_ADMIN') {
    if (!result || (Array.isArray(result) && !result.length)) return result

    _calculateDraftAdminColumns(resultAsArray[0], req.user.id)
  }

  calculateDraftTimeout(cqnScenario.scenario, resultAsArray, enhacnedWithLastChangeDateTime)

  if (cqnScenario.scenario === 'SIBLING_ENTITY') {
    if (!result || (Array.isArray(result) && !result.length)) return result

    if (resultAsArray[0].draftAdmin_inProcessByUser !== req.user.id) {
      return []
    }

    delete resultAsArray[0].draftAdmin_inProcessByUser
    _adaptDraftColumnsForSiblingEntity(resultAsArray[0], cqnScenario.isSiblingActive)
  }

  if (resultAsArray.length && Object.prototype.hasOwnProperty.call(resultAsArray[0], 'DraftAdministrativeData')) {
    resultAsArray.forEach(row => {
      row.DraftAdministrativeData && _calculateDraftAdminColumns(row.DraftAdministrativeData, req.user.id)
    })
  }
  postProcessVirtuals(virtuals, resultAsArray)
  return result
}

const { ODATA, COMMON } = require('../../common/constants/annotation')

const _relevant = e =>
  e[ODATA.DRAFT] ||
  Object.prototype.hasOwnProperty.call(e, COMMON.DRAFT_NODE.PREP_ACTION) ||
  e.name.endsWith('.DraftAdministrativeData')

module.exports = function () {
  for (const entity of Object.values(this.entities).filter(_relevant)) {
    this.on('READ', entity, _handler)
  }
}
