const DEBUG = /\b(true|y|all)\b/.test(process.env.DEBUG) && function (message) { console.warn(message ? '[DEBUG] - ' + message : '') }// eslint-disable-line
const _warn = (message) => { DEBUG && console.error('[WARNING] [hdbmigrationtable] - ', message) }  // eslint-disable-line
const path = require('path')
const { MigrationTableParser } = require('./migrationtable')
const { getProperty, BuildError } = require('../util')
const cdscVersion = `-- generated by cds-compiler version ${require('@sap/cds-compiler/package.json').version}`
const cds = require ('../cds'), minified = csn => cds.linked(csn).minified()
const { compiler:cdsc } = cds

module.exports = async (model, lastDevVersion, srcPath, options = {}) => {
  const journalEntityNames = _getJournalEntityNames(model)
  const { definitions, deletions, migrations, afterImage } = _toHdiMigration(model, lastDevVersion, journalEntityNames, options)
  const definitionResult = []

  for (const { name, suffix, sql } of definitions) {
    let definitionEntry = { name, suffix, content: sql }

    if (suffix === '.hdbtable') {
      if (journalEntityNames.has(name)) {
        const migration = migrations.find(migration => migration.name === name)
        definitionEntry = await _2migrationtable(srcPath, migration || _emptyMigration(name), sql, options)
      }
    }
    if (definitionEntry) {
      definitionResult.push(definitionEntry)
    }
  }
  return { definitions: definitionResult, deletions, afterImage }
}

function _toHdiMigration(model, lastDevVersion, journalEntityNames, options) {
  options.sqlChangeMode = getProperty(options, 'hana.journal.change-mode')
  const result = cdsc.to.hdi.migration(minified(model), options, lastDevVersion);
  if (DEBUG) {
    DEBUG('cdsc.to.hdi.migration returned')
    for (const { name, suffix, sql } of result.definitions) {
      if (suffix === '.hdbtable' || suffix === '.hdbmigrationtable') {
        if (journalEntityNames.has(name)) {
          const migration = result.migrations.find(migration => migration.name === name)
          DEBUG(`
File ${name + '.hdbmigrationtable'} - ${migration ? migration.changeset.length : 0} new changes
${sql}
${migration ? migration.changeset.map(change => change.sql).join('\n') : 'Empty changeset'}
`)
        }
      }
    }
  }
  return result
}

/**
 * Returns an object providing access to the .hdbmigrationtable file content and its corresponding filename.
 *
 * @param {String} srcPath Fully quailified path of the directory containing .hdbmigrationtable files
 * @param {String} migration the migration descriptor
 * @param {String} tableSql SQL TABLE definition
 * @param {Object} options compile options
 * @returns {Object} Providing access to 'content' and 'fileName'.
 */
async function _2migrationtable(srcPath, migration, tableSql, options) {
  let migrationTableModel = null
  const file = path.join(srcPath, migration.name + migration.suffix)
  try {
    migrationTableModel = await MigrationTableParser.read(file)
  } catch (e) {
    // abort build in order to ensure consistent afterImage model state / hdbmigrationtable file state
    throw new BuildError(`${path.relative(process.cwd(), file)}: ${e.message}`)
  }

  if (migrationTableModel) {
    // adding new changeset if change exist, ignore otherwise
    const migrationEntry = _getNewMigrationEntry(migration.changeset, migrationTableModel.versionNumber, options)
    if (migrationEntry) {
      const versionNumber = migrationTableModel.versionNumber + 1
      const migrations = `${migrationEntry.content}${migrationTableModel.migrations.entries.length > 0 ? '\n\n' : ''}${migrationTableModel.migrations.toString()}`
      return {
        name: migration.name,
        suffix: migration.suffix,
        content: `== version=${versionNumber}\n${tableSql}\n\n${migrations}`,
        changed: true,
        dropColumns: migrationEntry.dropColumns
      }
    } else {
      // existing migration file version
      return { name: migration.name, suffix: migration.suffix, content: migrationTableModel.toString(), changed: false }
    }
  }
  // initial migration file version
  return { name: migration.name, suffix: migration.suffix, content: `== version=1\n${tableSql}`, changed: true }
}

function _getNewMigrationEntry(changeset, currentVersion, options) {
  if (changeset && changeset.length > 0) {
    let dropColumns = false
    const enableDrop = getProperty(options, 'hana.journal.enable-drop')
    const changesetStr = changeset.map(entry => {
      dropColumns = dropColumns || entry.drop
      if (entry.drop && enableDrop !== true) {
        return entry.sql.replace(/^/gm, '-- ');
      }
      return entry.sql
    }).join('\n')

    if (!dropColumns || enableDrop === true) {
      return {
        dropColumns,
        content: `== migration=${currentVersion + 1}\n${cdscVersion}\n${changesetStr}`
      }
    } else {
      return {
        dropColumns,
        content: `== migration=${currentVersion + 1}
>>>>> Manual resolution required - DROP statements causing data loss are disabled by default.
>>>>> You may either:
>>>>>   uncomment statements to allow incompatible changes, or
>>>>>   refactor statements, e.g. replace DROP/ADD by single RENAME statement
>>>>> After manual resolution delete all lines starting with >>>>>
${cdscVersion}
${changesetStr}`
      }
    }
  }
  return null
}

function _emptyMigration(name) {
  return { name, suffix: ".hdbmigrationtable", changeset: [] }
}

function _getJournalEntityNames(model) {
  const journalNames = new Set(cds.reflect(model).all(item => {
    if (item.kind === 'entity' && item['@cds.persistence.journal'] === true) {
      if (item['@cds.persistence.skip'] === true || item['@cds.persistence.exists'] === true) {
        _warn(`Annotation @cds.persistence.journal skipped for entity '${item.name}' as persistence exists`)
      }
      return true
    }
    return false
  }).map(entity => entity.name))

  if (DEBUG) {
    DEBUG()
    DEBUG(`Found ${journalNames.size} model entities annotated with '@cds.persistence.journal`)
    DEBUG(`${[...journalNames].join(', ')}`)
  }
  return journalNames
}
