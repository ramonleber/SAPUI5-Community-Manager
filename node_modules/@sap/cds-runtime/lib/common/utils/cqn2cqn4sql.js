const cds = require('../../cds')
const { SELECT, INSERT, DELETE, UPDATE } = cds.ql

const { getOnCond } = require('../../common/utils/generateOnCond')
const { resolveView } = require('../utils/resolveView')
const { ensureNoDraftsSuffix } = require('../../common/utils/draft')
const { flattenStructured } = require('./structured')
const { foreignKeyPropagations } = require('../../common/utils/foreignKeyPropagations')

const _addOnCondToWhere = (cqn, entity, navigation, tableAlias, identifier, csn, prefix) => {
  const onConditionOptions = {
    associationNames: [...prefix, navigation],
    csn: csn,
    aliases: {
      select: tableAlias,
      join: identifier
    }
  }

  let element = csn.definitions[entity]
  for (let i = 0; i < onConditionOptions.associationNames.length; i++) {
    element = element.elements[onConditionOptions.associationNames[i]]
  }

  const onCond = getOnCond(element, onConditionOptions)

  cqn.where(onCond)
}

const _addAliasToElement = (e, alias) => {
  if (e.ref) {
    return { ref: [alias, ...e.ref] }
  }

  if (e.list) {
    return { list: e.list.map(arg => _addAliasToElement(arg, alias)) }
  }

  if (e.func) {
    const args = e.args.map(arg => _addAliasToElement(arg, alias))
    return { ...e, args }
  }

  return e
}

const _addAliasToExpression = (expression, alias) => {
  if (!alias) {
    return expression
  }

  return expression.map(e => _addAliasToElement(e, alias))
}

const _elementFromRef = (name, entity) => {
  if (!entity) return

  if (entity.elements) {
    return entity.elements[_getTargetFromRef(name)]
  }
}

const _getTargetFromRef = ref => {
  return ref.id || ref
}

const _getEntityName = (fromClause, entity, i) => {
  const targetName = _getTargetFromRef(fromClause.ref[i])
  return i === 0 ? targetName : entity.elements[targetName].target
}

const convertPathExpressionToWhere = (fromClause, model) => {
  if (fromClause.ref.length === 1) {
    const target = _getTargetFromRef(fromClause.ref[0])
    const alias = fromClause.as
    const { where, cardinality } = fromClause.ref[0]
    return { target, alias, where, cardinality }
  }

  let previousSelect, previousEntityName, previousTableAlias, structParent
  let prefix = []
  for (let i = 0; i < fromClause.ref.length; i++) {
    const entity = structParent || model.definitions[previousEntityName]
    const element = _elementFromRef(fromClause.ref[i], entity)

    if (element && element._isStructured) {
      prefix.push(element.name)
      structParent = element
      continue
    }

    if (element && element.isAssociation && fromClause.ref[i].where) {
      const target = element._target
      _modifyNavigationInWhere(fromClause.ref[i].where, target)
    }

    const currentEntityName = _getEntityName(fromClause, entity, i)
    const tableAlias = `T${i}`
    const currentSelect = SELECT.from(`${currentEntityName} as ${tableAlias}`)

    if (fromClause.ref[i].where) {
      currentSelect.where(_addAliasToExpression(fromClause.ref[i].where, tableAlias))
    }

    if (i !== fromClause.ref.length - 1) {
      currentSelect.columns([1])
    }

    if (previousSelect) {
      _addOnCondToWhere(
        previousSelect,
        previousEntityName,
        _getTargetFromRef(fromClause.ref[i]),
        tableAlias,
        previousTableAlias,
        model,
        prefix
      )

      currentSelect.where('exists', previousSelect)
    }

    structParent = undefined
    prefix = []
    previousTableAlias = tableAlias
    previousSelect = currentSelect
    previousEntityName = currentEntityName
  }

  return {
    target: previousEntityName,
    alias: previousTableAlias,
    where: previousSelect && previousSelect.SELECT && previousSelect.SELECT.where
  }
}

const _convertPathExpressionForInsertOrDelete = (intoClause, model) => {
  // .into is plain string or csn entity
  if (typeof intoClause === 'string' || intoClause.name) {
    return intoClause
  }

  return intoClause.ref.reduce((res, curr, i) => {
    if (i === 0) {
      return curr.id || curr
    }

    return model.definitions[res].elements[curr.id || curr].target
  }, '')
}

const _getBottomTopRefOrVal = (func, refVal) => {
  return func.args.filter(el => el[refVal])
}

const _getWindowWhere = (where, bottomTop) => {
  const windWhere = where || []
  const bottomTopVal = _getBottomTopRefOrVal(bottomTop[0], 'val')[0]
  bottomTopVal.val = parseInt(bottomTopVal.val, 10)

  if (windWhere.length > 0) {
    windWhere.push('and')
  }

  windWhere.push({ ref: ['rowNumber'] }, '<=', bottomTopVal)
  return windWhere
}

const _getOrderByForWindowFn = bottomTop => {
  const orderBy = _getBottomTopRefOrVal(bottomTop[0], 'ref')[0]
  orderBy.sort = bottomTop[0].func === 'topcount' ? 'desc' : 'asc'
  return orderBy
}

const _getWindowXpr = (groupBy, bottomTop) => {
  const xpr = [{ func: 'ROW_NUMBER', args: [] }, 'OVER', '(']
  xpr.push(
    'PARTITION BY',
    ...groupBy.reduce((acc, el, i) => {
      if (i < groupBy.length - 1) {
        acc.push(el)
        acc.push(',')
      } else {
        acc.push(el)
      }

      return acc
    }, [])
  )
  xpr.push('ORDER BY', _getOrderByForWindowFn(bottomTop))
  xpr.push(')')
  return { xpr: xpr, as: 'rowNumber' }
}

const _isBottomTop = columns => {
  return columns.some(el => el.func && (el.func === 'topcount' || el.func === 'bottomcount'))
}

const _getWindColumns = (columns, groupBy, bottomTop) => {
  return [].concat(columns, _getWindowXpr(groupBy, bottomTop))
}

const _createWindowCQN = (SELECT, model) => {
  const bottomTop = SELECT.columns.filter(el => _isBottomTop([el]))
  const columns = (SELECT.columns = [])
  const { elements } = model.definitions[SELECT.from.ref[0]]

  for (const el in elements) {
    if (!elements[el].isAssociation) {
      columns.push({ ref: [el] })
    }
  }

  SELECT.where = _getWindowWhere(SELECT.where, bottomTop)
  SELECT.from = {
    SELECT: {
      columns: _getWindColumns(columns, SELECT.groupBy, bottomTop),
      from: SELECT.from
    }
  }
  delete SELECT.groupBy
}

const _calculateColumnsToBeSearched = (cqn, model, target) => {
  // get default elements to be searched
  const entity = model.definitions[target] || { _searchableColumns: [] }

  // if there is a group by clause, only columns in it may be searched
  let toBeSearched = [...entity._searchableColumns]
  if (cqn.SELECT.groupBy) toBeSearched = toBeSearched.filter(tbs => cqn.SELECT.groupBy.some(gb => gb.ref[0] === tbs))
  toBeSearched = toBeSearched.map(c => ({ ref: [c] }))

  // add aggregations
  cqn.SELECT.columns &&
    cqn.SELECT.columns.forEach(column => {
      if (column.func) {
        toBeSearched.push(column)
        return
      }

      const columnRef = column.ref
      const columnName = columnRef[columnRef.length - 1]
      const csnColumn = entity.elements[columnName]
      if (!csnColumn) toBeSearched.push({ ref: [columnName] })
    })

  return toBeSearched
}

const _searchToLike = (cqn, model, target) => {
  const searchPhrase = cqn.SELECT.search
  const colsToBeSearched = _calculateColumnsToBeSearched(cqn, model, target)

  const xpr = []
  for (let i = 0; i < searchPhrase.length; i++) {
    const element = searchPhrase[i]
    if (element === 'not') continue
    if (element === 'or' || element === 'and') {
      xpr.push(element)
    } else {
      xpr.push('(')
      xpr.push(..._createLikeComparison(searchPhrase[i - 1] === 'not', colsToBeSearched, element))
      xpr.push(')')
    }
  }

  // REVISIT: find out here if where or having must be used
  cqn._aggregated ? cqn.having(xpr) : cqn.where(xpr)
}

const _createLikeComparison = (excludingSearch, columns, searchText) => {
  const likeExpression = []
  for (let i = 0; i < columns.length; i++) {
    // if negated search, we need to add is null check
    if (excludingSearch) {
      likeExpression.push('(')
      likeExpression.push(columns[i], 'IS NULL', 'OR')
    }
    likeExpression.push(
      'lower',
      '(',
      columns[i],
      ')',
      excludingSearch ? 'NOT LIKE' : 'LIKE',
      { val: `%${searchText.val.toLowerCase().replace(/(\^|_|%)/g, '^$1')}%` },
      'ESCAPE',
      "'^'"
    )

    if (excludingSearch) {
      likeExpression.push(')')
    }

    if (i !== columns.length - 1) {
      likeExpression.push(excludingSearch ? 'AND' : 'OR')
    }
  }

  return likeExpression
}

const _convertSelect = (cqn, model) => {
  // no path expression
  if (!cqn.SELECT.from.ref || (cqn.SELECT.from.ref.length === 1 && !cqn.SELECT.from.ref[0].where)) {
    // convert $search to where/having clause using like
    if (cqn.SELECT.search) {
      _searchToLike(cqn, model, cqn.SELECT.from.ref[0])
    }

    if (cqn.SELECT.columns && cds.env.effective.odata.structs) {
      flattenStructured(cqn.SELECT, model)
    }

    // topcount with groupby
    if (cqn.SELECT.columns && _isBottomTop(cqn.SELECT.columns)) {
      _createWindowCQN(cqn.SELECT, model)
    }

    return cqn
  }

  const { target, alias, where, cardinality } = convertPathExpressionToWhere(cqn.SELECT.from, model)
  const select = SELECT.from(target)

  if (alias) {
    select.SELECT.from.as = alias
  }

  // TODO: REVISIT: We need to add alias to subselect in .where, .columns, .from, ... etc
  if (where) {
    select.where(where)
  }

  if (cardinality && cardinality.max === 1) {
    cqn.SELECT.one = true
  }

  // convert $search to where/having clause using like
  if (cqn.SELECT.search) {
    _searchToLike(cqn, model, target)
  }

  if (cqn.SELECT.where) {
    select.where(_addAliasToExpression(cqn.SELECT.where, select.SELECT.from.as))
  }

  // We add all previous properties ot the newly created query.
  // Reason is to not lose the query API functionality
  Object.assign(select.SELECT, cqn.SELECT, { from: select.SELECT.from, where: select.SELECT.where })

  if (select.SELECT.columns && cds.env.effective.odata.structs) {
    flattenStructured(select.SELECT, model)
  }

  return select
}

const _getElement = (column, columns, target) => {
  if (!target) return

  if (columns) {
    // if columns is defined, column is index and row[column] should contain value that belongs to name in columns with same index
    return target.elements[columns[column]]
  }

  return target.elements[column]
}

const _handleArrayedElements = (rows, target, columns) => {
  for (const row of rows) {
    for (const column in row) {
      const element = _getElement(column, columns, target)

      if (element && element.is2one) {
        _handleArrayedElements([row[column]], element._target, columns)
      } else if (element && element.is2many) {
        _handleArrayedElements(row[column], element._target, columns)
      } else if (element && element._isStructured) {
        _handleArrayedElements([row[column]], element, columns)
      } else if (Array.isArray(row[column])) {
        row[column] = JSON.stringify(row[column])
      }
    }
  }
}

const _convertInsert = (cqn, model) => {
  // resolve path expression
  const resolvedIntoClause = _convertPathExpressionForInsertOrDelete(cqn.INSERT.into, model)

  // overwrite only .into, foreign keys are already set
  const insert = INSERT.into(resolvedIntoClause)

  // REVISIT flatten structured types, currently its done in SQL builder

  // We add all previous properties ot the newly created query.
  // Reason is to not lose the query API functionality
  Object.assign(insert.INSERT, cqn.INSERT, { into: resolvedIntoClause })

  const targetName = insert.INSERT.into.name || insert.INSERT.into
  const queryTarget = model.definitions[ensureNoDraftsSuffix(targetName)]

  if (cds.env.effective.odata.version !== 'v2') {
    if (cqn.INSERT.entries) {
      _handleArrayedElements(cqn.INSERT.entries, queryTarget)
    } else if (cqn.INSERT.rows) {
      _handleArrayedElements(cqn.INSERT.rows, queryTarget, cqn.INSERT.columns)
    } else if (cqn.INSERT.values) {
      _handleArrayedElements([cqn.INSERT.values], queryTarget, cqn.INSERT.columns)
    }
  }

  const target = model.definitions[targetName]
  if (!target) return insert

  const resolvedView = resolveView(insert, model, 'db')
  if (cqn.INSERT.into.ref && cqn.INSERT.into.ref.length > 1) {
    const copyFrom = [...cqn.INSERT.into.ref]
    copyFrom.pop()
    resolvedView._validationQuery = _convertSelect(SELECT.from({ ref: copyFrom }).columns([1]), model)
  }

  return resolvedView
}

function _modifyNavigationInWhere(whereClause, target) {
  whereClause.forEach(e => {
    if (e.ref && e.ref.length > 1 && target.elements[e.ref[0]]) {
      const element = target.elements[e.ref[0]]
      if (!element.isAssociation) return
      const foreignKeys = foreignKeyPropagations(element)
      const joined = e.ref.join('_')

      for (const { parentFieldName } of foreignKeys) {
        if (parentFieldName === joined) {
          e.ref = [joined]
        }
      }
    }
  })
}

const _plainDelete = (cqn, model) => {
  const name = cqn.DELETE.from.name || (cqn.DELETE.from.ref && cqn.DELETE.from.ref[0]) || cqn.DELETE.from
  const target = model.definitions[name]
  if (!target) return cqn

  return resolveView(cqn, model, 'db')
}

const _convertDelete = (cqn, model) => {
  // .from is plain string or csn entity
  if (
    typeof cqn.DELETE.from === 'string' ||
    cqn.DELETE.from.name ||
    (cqn.DELETE.from.ref && typeof cqn.DELETE.from.ref[0] === 'string')
  ) {
    return _plainDelete(cqn, model)
  }

  const { target, alias, where } = convertPathExpressionToWhere(cqn.DELETE.from, model)
  const deleet = DELETE('x')
  Object.assign(deleet.DELETE, cqn.DELETE, { from: target, where: undefined })

  if (alias) deleet.DELETE.from = { ref: [target], as: alias }
  if (where) deleet.where(where)
  if (cqn.DELETE.where) deleet.where(_addAliasToExpression(cqn.DELETE.where, alias))

  const targetEntity = model.definitions[target]
  if (!targetEntity) return deleet

  return resolveView(deleet, model, 'db')
}

function _plainUpdate(cqn, model) {
  const name = cqn.UPDATE.entity.name || (cqn.UPDATE.entity.ref && cqn.UPDATE.entity.ref[0]) || cqn.UPDATE.entity
  const queryTarget = model.definitions[ensureNoDraftsSuffix(name)]

  if (cds.env.effective.odata.version !== 'v2') {
    cqn.UPDATE.data && _handleArrayedElements([cqn.UPDATE.data], queryTarget)
    cqn.UPDATE.with && _handleArrayedElements([cqn.UPDATE.with], queryTarget)
  }

  const target = model.definitions[name]
  if (!target) return cqn

  return resolveView(cqn, model, 'db')
}

const _convertUpdate = (cqn, model) => {
  // REVISIT flatten structured types, currently its done in SQL builder

  // .into is plain string or csn entity
  if (
    typeof cqn.UPDATE.entity === 'string' ||
    cqn.UPDATE.entity.name ||
    (cqn.UPDATE.entity.ref && typeof cqn.UPDATE.entity.ref[0] === 'string')
  ) {
    return _plainUpdate(cqn, model)
  }

  const { target, alias, where } = convertPathExpressionToWhere(cqn.UPDATE.entity, model)

  // link .with and .data and set query target and remove current where clause
  // REVISIT: update statement does not accept cqn partial as input
  const update = UPDATE('x')
  Object.assign(update.UPDATE, cqn.UPDATE, { entity: target, where: undefined })

  if (alias) update.UPDATE.entity = { ref: [target], as: alias }
  if (where) update.where(where)
  if (cqn.UPDATE.where) update.where(_addAliasToExpression(cqn.UPDATE.where, alias))

  const queryTarget = model.definitions[target]

  if (cds.env.effective.odata.version !== 'v2') {
    cqn.UPDATE.data && _handleArrayedElements([cqn.UPDATE.data], queryTarget)
    cqn.UPDATE.with && _handleArrayedElements([cqn.UPDATE.with], queryTarget)
  }

  const targetEntity = model.definitions[target]
  if (!targetEntity) return update

  return resolveView(update, model, 'db')
}

/**
 * Converts a CQN with path expression into exists clause.
 * Converts insert/update/delete on view to target table including renaming of properties
 * REVISIT structured
 * REVISIT topcount when the additional layer for Analytics before SQLBuilder is ready
 *
 * @param {*} cqn - incoming query
 * @param {*} model - csn model
 */
module.exports = (cqn, model) => {
  if (cqn.DELETE) {
    return _convertDelete(cqn, model)
  }

  if (cqn.SELECT) {
    return _convertSelect(cqn, model)
  }

  if (cqn.INSERT) {
    return _convertInsert(cqn, model)
  }

  if (cqn.UPDATE) {
    return _convertUpdate(cqn, model)
  }

  return cqn
}
