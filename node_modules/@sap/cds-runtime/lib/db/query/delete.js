const { getFlatArray, processCQNs } = require('../utils/deep')
const { timestampToISO } = require('../data-conversion/timestamp')
const { hasCompositionDelete, createCascadeDeleteCQNs } = require('../../common/utils/composition/compositionTree')

const deleteFn = executeDeleteCQN => async (model, dbc, query, req) => {
  const ts = timestampToISO(req.timestamp)

  let result
  if (hasCompositionDelete(model && model.definitions, query)) {
    let cqns = createCascadeDeleteCQNs(model && model.definitions, query)

    // the delete chunks, i.e., how many deletes can be processed in parallel
    const chunks = []
    for (const each of cqns) chunks.push(each.length)

    cqns = getFlatArray(cqns)

    if (cqns.length === 0) return 0

    const results = await processCQNs(executeDeleteCQN, cqns, model, dbc, req.user, req.user.locale, ts, chunks)
    // return number of affected rows of "root cqn"
    result = results[0]
  } else {
    result = await executeDeleteCQN(model, dbc, query, req.user, req.user.locale, ts)
  }

  return result
}

module.exports = deleteFn
