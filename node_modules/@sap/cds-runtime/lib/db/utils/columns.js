const cds = require('../../cds')
const { isDraftEnabled } = require('../../common/utils/draft')
const resolveStructured = require('../../common/utils/resolveStructured')

const { DRAFT_COLUMNS } = require('../../common/constants/draft')

const _filterAssociationAndComposition = (entity, columnName) => {
  return entity.elements[columnName]
    ? entity.elements[columnName].is2one !== true && entity.elements[columnName].is2many !== true
    : true
}
const _filterDraft = (entity, columnName) => {
  return DRAFT_COLUMNS.includes(columnName) !== true && _filterAssociationAndComposition(entity, columnName)
}

const _mapNameToValue = (entity, array) => array.map(key => entity.elements[key] || { name: key })

/**
 * This method gets all columns for an entity.
 * It includes the generated foreign keys from managed associations, structured elements and complex and custom types.
 * As well, it provides the annotations starting with '@' for each column.
 *
 * @param entity - the csn entity
 * @returns {Array} - array of columns
 */
const getColumns = entity => {
  let columnNames
  // REVISIT!!!
  const proto = Object.getPrototypeOf(entity.elements)
  if (proto) columnNames = Object.keys(proto)
  else columnNames = Object.keys(entity.elements)

  if (cds.env.effective.odata.structs) {
    const toBeDeleted = []
    for (const column of columnNames) {
      const element = entity.elements[column]
      if (element && element.elements) {
        toBeDeleted.push(column)
        columnNames.push(
          ...resolveStructured({ structName: element.name, structProperties: [] }, element.elements, false)
        )
      }
    }

    columnNames = columnNames.filter(col => !toBeDeleted.includes(col))
  }

  if (isDraftEnabled(entity)) {
    return _mapNameToValue(
      entity,
      columnNames.filter(key => _filterDraft(entity, key))
    )
  }

  return _mapNameToValue(
    entity,
    columnNames.filter(key => _filterAssociationAndComposition(entity, key))
  )
}

module.exports = getColumns
