const cds = require('../../../../cds')

const { StatusCodes: HttpStatusCodes } = require('../okra/odata-commons/http/HttpStatusCode')

const ERROR_TO_STRING_CODE = {
  // copied from okra tests
  UriSemanticError: String(HttpStatusCodes.NOT_FOUND),
  UriQueryOptionSemanticError: String(HttpStatusCodes.BAD_REQUEST),
  UriSyntaxError: String(HttpStatusCodes.BAD_REQUEST),
  NotImplementedError: String(HttpStatusCodes.NOT_IMPLEMENTED),
  MethodNotAllowedError: String(HttpStatusCodes.METHOD_NOT_ALLOWED),
  NotAcceptableError: String(HttpStatusCodes.NOT_ACCEPTABLE),
  NotAuthorizedError: String(HttpStatusCodes.UNAUTHORIZED),
  InternalServerError: String(HttpStatusCodes.INTERNAL_SERVER_ERROR),
  PreconditionFailedError: String(HttpStatusCodes.PRECONDITION_FAILED),
  PreconditionRequiredError: String(HttpStatusCodes.PRECONDITION_REQUIRED),
  ConflictError: String(HttpStatusCodes.CONFLICT),
  NotFoundError: String(HttpStatusCodes.NOT_FOUND),
  BadRequestError: String(HttpStatusCodes.BAD_REQUEST),
  // custom
  SerializationError: String(HttpStatusCodes.INTERNAL_SERVER_ERROR),
  DeserializationError: String(HttpStatusCodes.BAD_REQUEST)
}

const { normalizeError } = require('../../../../common/error/frontend')

const _isStandardError = err => {
  return (
    err instanceof TypeError ||
    err instanceof ReferenceError ||
    err instanceof SyntaxError ||
    err instanceof RangeError ||
    err instanceof URIError
  )
}

const _beautifyMessage = msg => (msg.endsWith('.') ? msg : msg + '.')

const _buildRootCauseMessage = (message, rootCause) => {
  if (rootCause) {
    message = _beautifyMessage(message) + ' ' + _beautifyMessage(rootCause.message)

    if (typeof rootCause.getRootCause === 'function') {
      message = _buildRootCauseMessage(message, rootCause.getRootCause())
    }
  }

  return message
}

const _betterOkraError = err => {
  err.code = ERROR_TO_STRING_CODE[err.name] || '500'
  err.message = _buildRootCauseMessage(err.message, err.getRootCause())

  if (err.name === 'DeserializationError') {
    err.message = err.message.replace('Error while deserializing payload.', 'Deserialization Error:')
    err.message = err.message.replace(' An error occurred during deserialization of the entity.', '')
  } else if (err.name === 'SerializationError') {
    err.message = err.message.replace('An error occurred during serialization of the entity.', 'Serialization Error:')
    err.message = err.message.replace(
      'An error occurred during serialization of the entity collection. An error occurred during serialization of',
      'Serialization Error for'
    )
  }

  return err
}

/**
 * Custom error handler.
 * Crashes the node instance, if not deactivated.
 *
 * @param {boolean} crashOnError
 * @returns {Function}
 */
const getErrorHandler = (crashOnError = true, srv) => {
  return (odataReq, odataRes, next, err) => {
    // REVISIT: crashOnError
    if (_isStandardError(err) && crashOnError) {
      err.__crashOnError = true
      throw err
    }

    // get req for i18n
    let req
    const isBatch = odataReq.getBatchApplicationData() !== null
    if (isBatch) {
      req = odataReq.getBatchApplicationData().req
    } else {
      req = odataReq.getIncomingRequest()
    }

    // invoke srv.on('error', function (err, req) { ... }) here in special situations
    // REVISIT: if for compat reasons, remove once cds^5.1
    if (srv._handlers._error) {
      const ctx = cds.context
      if (!ctx) {
        // > error before req was dispatched
        for (const each of srv._handlers._error) each.handler.call(srv, err, { _: { req, res: req.res } })
      } else if (err.getRootCause) {
        // > error after req was dispatched
        for (const each of srv._handlers._error) each.handler.call(srv, err, ctx)
      }
    }

    if (err.getRootCause && typeof err.getRootCause === 'function') {
      // > an OKRA error
      err = _betterOkraError(err)
    }

    const { error, statusCode } = normalizeError(err, req)

    next(null, Object.assign(error, { statusCode }))
  }
}

module.exports = getErrorHandler
