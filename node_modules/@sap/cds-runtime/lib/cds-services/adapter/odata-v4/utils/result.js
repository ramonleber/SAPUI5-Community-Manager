const cds = require('../../../../cds')
const getTemplate = require('../../../../common/utils/template')
const templateProcessor = require('../../../../common/utils/templateProcessor')
const Big = require('@sap/cds-foss')('big.js')
const { isBacklink } = require('../../../../common/utils/composition/backlinks')

const METADATA = {
  $context: '*@odata.context',
  $count: '*@odata.count',
  $etag: '*@odata.etag',
  $metadataEtag: '*@odata.metadataEtag',
  $bind: '*@odata.bind',
  $id: '*@odata.id',
  $delta: '*@odata.delta',
  $removed: '*@odata.removed',
  $type: '*@odata.type',
  $nextLink: '*@odata.nextLink',
  $deltaLink: '*@odata.deltaLink',
  $editLink: '*@odata.editLink',
  $readLink: '*@odata.readLink',
  $navigationLink: '*@odata.navigationLink',
  $associationLink: '*@odata.associationLink',
  $mediaEditLink: '*@odata.mediaEditLink',
  $mediaReadLink: '*@odata.mediaReadLink',
  $mediaContentType: '*@odata.mediaContentType',
  $mediaEtag: '*@odata.mediaEtag'
}

/**
 * Convert any result to the result object structure, which is expected of odata-v4.
 *
 * @param {*} result
 * @param {*} [arg]
 * @returns {string | object}
 */
const toODataResult = (result, arg) => {
  if (result === undefined || result === null) return ''

  if (arg) {
    if (typeof arg === 'object') {
      arg = arg._.odataReq.getUriInfo().getLastSegment().isCollection() ? 'Array' : ''
    }
    if (!Array.isArray(result) && arg === 'Array') {
      result = [result]
    } else if (Array.isArray(result) && arg !== 'Array') {
      result = result[0]
    }
  }

  const odataResult = {
    value: result
  }

  if (typeof result === 'object') {
    for (const key in METADATA) {
      if (key in result) {
        odataResult[METADATA[key]] = result[key]
        delete result[key]
      }
    }
  }

  return odataResult
}

const getVirtualsFromResult = ({ elements }, result) => {
  const virtuals = {}
  for (const k in elements) {
    if (elements[k].virtual) virtuals[k] = result[k]
  }
  return virtuals
}

const addEtags = (row, key) => {
  row['*@odata.etag'] = row[key]
}

const convertDecimal = (row, key, options) => {
  const bigValue = new Big(row[key])
  row[key] = options.decimals.exponential ? bigValue.toExponential() : bigValue.toFixed()
}

const addAssociationToRow = (row, foreignKey, foreignKeyElement) => {
  const assocName = foreignKeyElement['@odata.foreignKey4']
  const assoc = foreignKeyElement.parent.elements[assocName]

  if (!row[assocName]) {
    row[assocName] = {}
  }

  const keyOfAssociatedEntity = foreignKey.replace(`${assocName}_`, '')

  if (assoc._target.keys[keyOfAssociatedEntity]['@odata.foreignKey4']) {
    // assoc as key
    row[assocName][keyOfAssociatedEntity] = row[foreignKey]
    delete row[foreignKey]
    addAssociationToRow(row[assocName], keyOfAssociatedEntity, assoc._target.keys[keyOfAssociatedEntity])
    return
  }

  // foreign key null or undefined, set assoc to null
  if (row[foreignKey] == null) {
    row[assocName] = null
    delete row[foreignKey]
    return
  }

  if (row[assocName][keyOfAssociatedEntity] === undefined) {
    row[assocName][keyOfAssociatedEntity] = row[foreignKey]
  }
  delete row[foreignKey]
}

const _processCategory = (category, row, key, element, options) => {
  switch (category) {
    case '@odata.etag':
      addEtags(row, key)
      break
    case '@cds.Decimal':
      if (options.decimals && row[key]) convertDecimal(row, key, options)
      break
    case '@odata.foreignKey4':
      addAssociationToRow(row, key, element)
      break
    case '@cleanup':
      delete row[key]
      break
  }
}

const _processorFn = options => (row, key, element, plain) => {
  if (typeof row !== 'object' || !Object.prototype.hasOwnProperty.call(row, key)) return
  const categories = plain.categories
  if (Array.isArray(row)) throw new Error('oops')
  for (const category of categories) {
    _processCategory(category, row, key, element, options)
  }
}

const _getParent = (model, name) => {
  const target = model.definitions[name]
  if (target && target.elements) {
    for (const elementName in target.elements) {
      const element = target.elements[elementName]
      const assoc = element.target && model.definitions[element.target]
      if (assoc && element._isAssociationStrict && isBacklink(element, assoc, true)) return assoc
    }
  }
  return null
}

const _isUpAssoc = (element, parent) =>
  element &&
  cds.env.effective.odata.containment &&
  /^up_(_up_)*$/.test(element.name) &&
  _isContainedOrBackLink(element, parent)

const _isContainedOrBackLink = (element, parent) =>
  element && element.isAssociation && element.keys && (element._isContained || isBacklink(element, parent, true))

const _assocs = (element, target, parent) => {
  const assocName = element['@odata.foreignKey4']
  const assoc = assocName && target.elements[assocName]
  if (cds.env.effective.odata.refs) {
    // expand assoc keys except of up_ backlinks
    if (element['@odata.foreignKey4'] && !_isUpAssoc(assoc, parent)) {
      return ['@odata.foreignKey4']
    }
    if (element['@odata.containment.ignore']) {
      return ['@cleanup']
    }
  }
  if (_isContainedOrBackLink(assoc, parent)) {
    return ['@cleanup']
  }
  return []
}

const _pick = (element, target, parent) => {
  const categories = []

  if (element['@odata.etag']) categories.push('@odata.etag')
  if (element.type === 'cds.Decimal') categories.push('@cds.Decimal')
  categories.push(..._assocs(element, target, parent))

  if (categories.length) return { categories }
}

const postProcess = ({ headers, target }, result, service) => {
  const { model } = service
  const options = {}

  if (!target || !result || !model || !model.definitions[target.name]) return

  // REVISIT: options ie headers are not used in _pick since its cached
  // consequently, all decimals are always picked even w/o these headers
  if (headers && headers.accept && headers.accept.includes('IEEE754Compatible=true')) {
    options.decimals = { exponential: headers.accept.includes('ExponentialDecimals=true') }
  }

  const template = getTemplate('postProcess', service, target, { pick: _pick }, _getParent(model, target.name))
  if (template.elements.size !== 0) {
    // normalize result to rows
    result = result.value && Object.keys(result).filter(k => !k.match(/^\W/)).length === 1 ? result.value : result
    const rows = Array.isArray(result) ? result : [result]
    // process each row
    const processFn = _processorFn(options)
    for (const row of rows) {
      const args = { processFn, row, template }
      templateProcessor(args)
    }
  }
}

module.exports = {
  toODataResult,
  getVirtualsFromResult,
  postProcess
}
