"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyStrategy = exports.proxyAgent = exports.addProxyConfigurationInternet = exports.parseProxyEnv = exports.proxyStrategy = void 0;
var http_proxy_agent_1 = require("http-proxy-agent");
var https_proxy_agent_1 = require("https-proxy-agent");
var util_1 = require("@sap-cloud-sdk/util");
var get_protocol_1 = require("./get-protocol");
var protocol_1 = require("./protocol");
var authorization_header_1 = require("./authorization-header");
var logger = util_1.createLogger({
    package: 'core',
    messageContext: 'proxy-util'
});
/**
 * Determines the proxy strategy. If noProxy is set the ProxyConfiguration in the destination is omitted.
 * For onPremProxy or internetProxy the connectivy service or enviroment variables are checked to fill the [[ProxyConfiguration]].
 * @param destination - from which the proxy strategy is derived.
 * @returns ProxyStrategy possible values are noProxy, internetProxy or onPremProxy.
 */
function proxyStrategy(destination) {
    if (destination.proxyType === 'OnPremise') {
        logger.info('OnPrem destination proxy settings from connectivity service will be used.');
        return ProxyStrategy.ON_PREMISE_PROXY;
    }
    var destinationProtocol = get_protocol_1.getProtocolOrDefault(destination);
    if (!getProxyEnvValue(destinationProtocol)) {
        logger.info("No Proxy settings for " + destinationProtocol + " are found in environment variables - no proxy used");
        return ProxyStrategy.NO_PROXY;
    }
    if (getNoProxyEnvValue().includes(destination.url)) {
        logger.info("Destination URL " + destination.url + " is in no_proxy list: " + getNoProxyEnvValue() + " - no proxy used");
        return ProxyStrategy.NO_PROXY;
    }
    if (getProxyEnvValue(destinationProtocol)) {
        logger.info("Proxy settings for " + destinationProtocol + " are found in environment variables.");
        return ProxyStrategy.INTERNET_PROXY;
    }
    return ProxyStrategy.NO_PROXY;
}
exports.proxyStrategy = proxyStrategy;
function getProxyEnvValue(protocol) {
    var proxyEnvKey = protocol + '_proxy';
    var proxyEnvValue = process.env[proxyEnvKey.toLowerCase()] ||
        process.env[proxyEnvKey.toUpperCase()];
    logger.info("Try to fetch " + proxyEnvKey.toLowerCase() + " or " + proxyEnvKey.toUpperCase() + " from the process env. Found value is " + proxyEnvValue);
    if (!proxyEnvValue) {
        return undefined;
    }
    return proxyEnvValue;
}
function getNoProxyEnvValue() {
    var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
    if (!noProxyEnv) {
        return [];
    }
    var split = noProxyEnv.split(',').map(function (s) { return s.trim(); });
    if (split.find(function (s) { return s.includes('*'); })) {
        logger.warn("The no_proxy env contains a wildcard " + noProxyEnv + ", which is currently not supported");
    }
    return split;
}
var addProtocol = function (groups) { return function (proxyConfiguration) {
    if (!proxyConfiguration) {
        return;
    }
    var copy = __assign({}, proxyConfiguration);
    if (!groups.protocol) {
        copy.protocol = protocol_1.Protocol.HTTP;
        logger.info('Protocol not specified in proxy environment value. Http used as fallback.');
        return copy;
    }
    copy.protocol = protocol_1.Protocol.of(groups.protocol);
    if (!copy.protocol) {
        logger.warn("Unsupported protocol requested in environment variable: " + groups.protocol + ". Supported values are http and https - no proxy used.");
        return undefined;
    }
    if (copy.protocol === protocol_1.Protocol.HTTPS) {
        logger.info("You are using https to connect to a proxy\" " + proxyConfiguration + " - this is unusual but possible.");
    }
    return copy;
}; };
var addPort = function (groups) { return function (proxyConfiguration) {
    if (!proxyConfiguration) {
        return;
    }
    var copy = __assign({}, proxyConfiguration);
    if (groups.port) {
        if (groups.port.match(/[\D]/)) {
            logger.warn('Given port in proxy env variable is not an integer - no proxy used.');
            return undefined;
        }
        copy.port = parseInt(groups.port);
        return copy;
    }
    var fallBackPort = proxyConfiguration.protocol === protocol_1.Protocol.HTTPS ? 443 : 80;
    copy.port = fallBackPort;
    logger.info("Port not specified in proxy environment value. " + fallBackPort + " used as fallback.");
    return copy;
}; };
var addAuthHeaders = function (groups) { return function (proxyConfiguration) {
    if (!proxyConfiguration) {
        return;
    }
    var copy = __assign({}, proxyConfiguration);
    if (!groups.user || !groups.pwd) {
        logger.debug('No user and password given in proxy environment value. Nothing added to header.');
        return copy;
    }
    if (groups.user.match(/[^\w%]/) || groups.pwd.match(/[^\w%]/)) {
        logger.warn('Username:Password in proxy environment variable contains special characters like [@/:]. Use percent-encoding to mask them - no Proxy used');
        return undefined;
    }
    var userDecoded = decodeURIComponent(groups.user);
    var pwdDecoded = decodeURIComponent(groups.pwd);
    copy.headers = {
        'Proxy-Authorization': authorization_header_1.basicHeader(userDecoded, pwdDecoded)
    };
    logger.info('Username and password added to authorization of the proxy configuration.');
    return copy;
}; };
var addHost = function (groups) { return function (proxyConfiguration) {
    if (groups.host) {
        proxyConfiguration.host = groups.host;
        return proxyConfiguration;
    }
    logger.warn('Could not extract host from proxy env. - no proxy used');
    return;
}; };
/**
 * Parses the environment variable for the web proxy and extracts the values considering defaults like http for the protocol and 80 or 443 for the port.
 * The general pattern to be parsed is protocol://user:password@host:port, where everything besides the host is optional.
 * Special characters in the user and password need to be percent encoded.
 * @param proxyEnvValue - Environment variable which is parsed
 * @returns Configuration with default values or undefined if the parsing failed.
 */
function parseProxyEnv(proxyEnvValue) {
    var regex = /(?<protocolWithDelimiter>(?<protocol>^.+):\/\/)?(?<userPwdWithDelimeter>(?<user>.+):(?<pwd>.+)@)?(?<hostAndPort>(?<host>[\w.]+):?(?<port>.+)?)/;
    var parsed = regex.exec(proxyEnvValue);
    if (parsed === null || parsed === void 0 ? void 0 : parsed.groups) {
        var groups = parsed.groups;
        logger.debug("Start to extract protocol, host and port from proxy env: " + proxyEnvValue);
        var proxyConfiguration = addHost(groups)({});
        proxyConfiguration = addProtocol(groups)(proxyConfiguration);
        proxyConfiguration = addPort(groups)(proxyConfiguration);
        proxyConfiguration = addAuthHeaders(groups)(proxyConfiguration);
        if (proxyConfiguration) {
            logger.debug("Used Proxy Configuration:\n     host:" + proxyConfiguration.host + "\n     protocol:" + proxyConfiguration.protocol + "\n     port:" + proxyConfiguration.port + "\n     headers: " + (proxyConfiguration.headers
                ? 'Authorization header present - Not logged for security reasons.'
                : 'No header present.') + ".");
        }
        return proxyConfiguration;
    }
    logger.warn("Unable to extract proxy config from " + proxyEnvValue + ".");
}
exports.parseProxyEnv = parseProxyEnv;
/**
 * Adds the proxy configuration to a destination based on web proxies defined in environment variables. See [[ProxyConfiguration]] and [[proxyStrategy]] for details.
 * @param destination - to which the proxy configuration is added.
 * @returns Destination containing the configuration for web proxy.
 */
function addProxyConfigurationInternet(destination) {
    var proxyEnvValue = getProxyEnvValue(get_protocol_1.getProtocolOrDefault(destination));
    if (proxyEnvValue) {
        var proxyConfiguration = parseProxyEnv(proxyEnvValue);
        if (proxyConfiguration) {
            return __assign(__assign({}, destination), { proxyConfiguration: proxyConfiguration });
        }
        return __assign({}, destination);
    }
    logger.warn('Attempt to get proxy config from environment variables failed. At this point this should not happen - no proxy used.');
    return __assign({}, destination);
}
exports.addProxyConfigurationInternet = addProxyConfigurationInternet;
/**
 * Builds the http(s)-agent config. Note that the proxy agent type like http or https is determined by the destination RUL protocol.
 * The protocol from the proxy is unrelated to this and in most cases http.
 * All additional options are forwarded to tls.connect and net.connect see https://github.com/TooTallNate/node-https-proxy-agent#new-httpsproxyagentobject-options
 *
 * @param destination - Destination containing the proxy configurations
 * @param options - Addiotional options for the agent
 * @returns The http(s)-agent containing the proxy configuration
 */
function proxyAgent(destination, options) {
    var targetProtocol = get_protocol_1.getProtocolOrDefault(destination);
    var proxyConfig = destination.proxyConfiguration;
    if (!proxyConfig) {
        throw new Error('Proxy config must not be undefined.');
    }
    if (options === null || options === void 0 ? void 0 : options.host) {
        logger.warn("The agent options you passed to the proxy agent creation contains the host \"" + options.host + "\" which will overwrite the host from the proxy config.");
    }
    if (options === null || options === void 0 ? void 0 : options.port) {
        logger.warn("The agent options you passed to the proxy agent creation contains the port \"" + options.port + "\" which will overwrite the port from the proxy config.");
    }
    var agentConfig = __assign({ host: proxyConfig.host, protocol: proxyConfig.protocol, port: proxyConfig.port }, options);
    switch (targetProtocol) {
        case protocol_1.Protocol.HTTP:
            return {
                httpAgent: new http_proxy_agent_1.HttpProxyAgent(agentConfig)
            };
        case protocol_1.Protocol.HTTPS:
            return {
                httpsAgent: new https_proxy_agent_1.HttpsProxyAgent(agentConfig)
            };
    }
}
exports.proxyAgent = proxyAgent;
/**
 * Enum representing the different strategies for proxying request. Possible situations are "NO_PROXY", use the connectivity service proxy for On-Premise connection or a usual web proxy.
 * See also [[ProxyConfiguration]] for more details.
 */
var ProxyStrategy;
(function (ProxyStrategy) {
    ProxyStrategy[ProxyStrategy["NO_PROXY"] = 0] = "NO_PROXY";
    ProxyStrategy[ProxyStrategy["ON_PREMISE_PROXY"] = 1] = "ON_PREMISE_PROXY";
    ProxyStrategy[ProxyStrategy["INTERNET_PROXY"] = 2] = "INTERNET_PROXY";
})(ProxyStrategy = exports.ProxyStrategy || (exports.ProxyStrategy = {}));
//# sourceMappingURL=proxy-util.js.map