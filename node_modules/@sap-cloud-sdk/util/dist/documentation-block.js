"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.documentationBlock = void 0;
var array_1 = require("./array");
var logger_1 = require("./logger");
var string_formatter_1 = require("./string-formatter");
var logger = logger_1.createLogger('documentation-block');
/**
 * @experimental This API is experimental and might change in newer versions. Use with caution.
 * Transform strings and arguments to a string formatted as a documentation block.
 * The formatting is block like so no leading or trailing spaces.
 * New lines in the beginning and end are also removed.
 * Use in tagged templates, e. g.:
 * ```
 * documentationBlock`Docs with ${arguments} and more content;`
 * ```
 * @param strings Strings in the tagged template. In the example above that would be ['Docs with ', ' and more content;'].
 * @param args Arguments in the tagged template. In the example above that would be the resolved value for `arguments`;
 * @returns A string formatted as documentation block.
 */
function documentationBlock(strings) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var firstLineTrimmed = removeLeadingEmptyLines(strings.raw[0]);
    var textIndentation = getIndentation(firstLineTrimmed);
    var argsWithIndentation = addIndentationToArgumnets(args, textIndentation);
    var content = array_1.zip(__spreadArrays([firstLineTrimmed], strings.raw.slice(1)), argsWithIndentation).join('');
    // If no text is given return just empty string.
    if (!content.match(/\w/)) {
        return '';
    }
    content = maskProblematicCharacters(content);
    var lines = content.split(string_formatter_1.unixEOL);
    lines = adjustIndentation(lines, textIndentation);
    content = lines.join(string_formatter_1.unixEOL + " * ");
    var result = ['/**', " * " + content, ' */'].join(string_formatter_1.unixEOL);
    return result;
}
exports.documentationBlock = documentationBlock;
/*
New lines at the beginning are mainly unintentional when you make documentationBlock`
myContent
`
 */
function removeLeadingEmptyLines(firstLine) {
    var lines = firstLine.split(string_formatter_1.unixEOL);
    var indexFirstNonEmpty = lines.findIndex(function (str) { return str.match(/\w/); }) || 0;
    return lines.splice(indexFirstNonEmpty).join(string_formatter_1.unixEOL);
}
/*
 The arguments do not contain any indentation so this is added via this method.
 */
function addIndentationToArgumnets(args, textIndentation) {
    var argsWithIndentation = args.map(function (arg) {
        return arg.replace(/\n/g, string_formatter_1.unixEOL + ' '.repeat(textIndentation));
    });
    return argsWithIndentation;
}
/*
 Takes the first text line as reference and does indentation with respect to this line.
 */
function adjustIndentation(lines, textIndentation) {
    return lines.map(function (str) { return str.slice(textIndentation); });
}
/*
 Searches for the first line containing text and returns the number of white spaces in that line.
 */
function getIndentation(firstLine) {
    var removeStarting = firstLine === null || firstLine === void 0 ? void 0 : firstLine.replace(/^\n*/g, '');
    var countEmptySpaces = removeStarting === null || removeStarting === void 0 ? void 0 : removeStarting.search(/\S/);
    return countEmptySpaces > 0 ? countEmptySpaces : 0;
}
function maskProblematicCharacters(str) {
    if (str.includes('*/')) {
        logger.warn("The documentation block " + str + "'\n      )} contained */ in the text will be masked as \\*\\/.");
    }
    return str.replace(/\*\//g, '\\*\\/');
}
//# sourceMappingURL=documentation-block.js.map