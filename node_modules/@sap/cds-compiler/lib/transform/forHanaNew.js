'use strict';

const { setProp, isBetaEnabled, isDeprecatedEnabled } = require('../base/model');
const { getUtils, cloneCsn, forEachGeneric,
        forEachDefinition, forEachMember,
        forEachMemberRecursively, forEachRef,
        forAllQueries, forAllElements, hasBoolAnnotation, getArtifactDatabaseNameOf,
        getElementDatabaseNameOf, isBuiltinType, applyTransformations,
        isPersistedOnDatabase, getNormalizedQuery, isAspect
      } = require('../model/csnUtils');
const { handleMessages, makeMessageFunction } = require('../base/messages');
const transformUtils = require('./transformUtilsNew');
const { translateAssocsToJoinsCSN } = require('./translateAssocsToJoins');
const { csnRefs, pathId, implicitAs } = require('../model/csnRefs');
const { getServiceNames } = require('./forOdataNew');
const { checkCSNVersion } = require('../json/csnVersion');
const validate = require('../checks/validator');
const { addLocalizationViewsWithJoins, addLocalizationViews } = require('../transform/localized');
const timetrace = require('../utils/timetrace');
const { createReferentialConstraints, assertConstraintIdentifierUniqueness } = require('./constraints');
const { createDict } = require('../utils/objectUtils');

/**
 * If a mixin association is published, return the mixin association.
 *
 * @param {CSN.Query} query Query of the artifact to check
 * @param {object} association Association (Element) published by the view
 * @returns {object} The mixin association
 */
function getMixinAssocOfQueryIfPublished(query, association, associationName) {
  if (query && query.SELECT && query.SELECT.mixin) {

    const aliasedColumnsMap = Object.create(null);
    if(query.SELECT.columns) {
      for(const column of query.SELECT.columns) {
        if(column.as && column.ref && column.ref.length === 1) {
          aliasedColumnsMap[column.as] = column;
        }
      }
    }

    for (const elem of Object.keys(query.SELECT.mixin)) {
      const mixin_element = query.SELECT.mixin[elem];
      let originalName = associationName;
      if(aliasedColumnsMap[associationName]) {
        originalName = aliasedColumnsMap[associationName].ref[0];
      }
      if (elem === originalName)
        return { mixinElement: mixin_element, mixinName: originalName };
    }
  }
  return {};
}

/**
 * Check wether the given artifact uses the given mixin association.
 *
 * @param {CSN.Query} query Query of the artifact to check
 * @param {object} association Mixin association (Element) to check for
 * @returns {Boolean} True if used
 */
function usesMixinAssociation(query, association, associationName) {
  if (query && query.SELECT && query.SELECT.columns) {
    for (const column of query.SELECT.columns) {
      if (typeof column === 'object' && column.ref && column.ref.length > 1 && (column.ref[0] == associationName || column.ref[0].id == associationName)) {
        // FIXME: This is not necessarily correct: the assoc name needs not be the first component, as e.g. $projection.assoc
        // would be also valid. Check other paths like $self.assoc ....
        return true;
      }
    }
  }
  return false;
}


/**
 * Return a copy of the compact CSN model with a number of transformations made for rendering
 * in HANA CDS style, used by 'toHana', toSql' and 'toRename'.
 * The behavior is controlled by the following options:
 * options = {
 *    forHana.names                               // See the behavior of 'names' in toHana, toSql and toRename
 *    forHana.keepNamespaces                      // Do not transform namespaces to contexts (to be used for
 *                                                // producing HANA-CDS compatible names with 'toHana', 'toSql' ...)
 *    forHana.keepStructsAssocs                   // Do not flatten structs, do not convert managed assocs to
 *                                                // unmanaged ones, do not convert assocs to joins (to be used
 *                                                // for rendering strictly HANA-CDS compatible CDS source with
 *                                                // 'toHana')
 *    forHana.alwaysResolveDerivedTypes           // Always resolve derived type chains (by default, this is only
 *                                                // done for 'quoted' names). FIXME: Should always be done in general.
 * }
 * The result model will always have 'options.forHana' set, to indicate that these transformations have happened.
 * The following transformations are made:
 * - (000) Some primitive type names are mapped to HANA type names (e.g. DateTime => UTCDateTime,
 *         Date => LocalDate, ...).The primitive type 'UUID' is renamed to 'String' (see also 060 below).
 * - (001) Add a temporal where condition to views where applicable before assoc2join
 * - (010) (not for 'keepStructsAssocs'): Transform associations to joins
 * - (015) Draft shadow entities are generated for entities/views annotated with '@odata.draft.enabled'.
 * - (020) Check: in "plain" mode, quoted ids are not allowed.
 *         (a) check in namespace declarations
 *         (b) check in artifact/element definitions.
 * - (030) For all elements, derived types are replaced by their final base type.
 * - (040) Abstract entities and entities 'implemented in' something are ignored, as well
 *         as entities annotated with '@cds.persistence.skip' or '@cds.persistence.exists'.
 * - (045) The query is stripped from entities that are annotated with '@cds.persistence.table',
 *         essentially converting views to entities.
 * - (050) Checks on the hierarchical model (pre-flattening)
 *         array of, @cds.valid.from/to
 * - (060) Users of primitive type 'UUID' (which is renamed to 'String' in 000) get length 36'.
 * - (070) Default length 5000 is supplied for strings if not specified.
 * - (080) Annotation definitions are ignored (note that annotation assignments are filtered out by toCdl).
 * - (090) Compositions become associations.
 * - (100) 'masked' is ignored (a), and attribute 'localized' is removed (b)
 * - (110) Actions and functions (bound or unbound) are ignored.
 * - (120) (a) Services become contexts.
 *         (b) (not for 'keepNamespaces'): Namespaces become contexts.
 * - (130) (not for 'keepStructsAssocs'): Elements having structured types are flattened into
 *         multiple elements (using '_' or '.' as name separator, depending on 'forHana.names').
 * - (140) (not for 'keepStructsAssocs'): Managed associations get explicit ON-conditions, with
 *         generated foreign key elements (also using '_' or '.' as name separator, depending on 'forHana.names').
 * - (150) (a) Elements from inherited (included) entities are copied into the receiving entity
 *         (b) The 'include' property is removed from entities.
 * - (160) Projections become views, with MIXINs for association elements (adding $projection where
 *         appropriate for ON-conditions).
 * - (170) ON-conditions referring to '$self' are transformed to compare explicit keys instead.
 * - (180) In projections and views, ...
 *         (a) association elements that are mixins must not be explicitly redirected
 *         (b) MIXINs are created for association elements in the select list that are not mixins by themselves.
 * - (190) For all enum types, ...
 *         (a) enum constants in defaults are replaced by their values (assuming a matching enum as element type)
 *         (b) the enum-ness is stripped off (i.e. the enum type is replaced by its final base type).
 * - (200) The 'key' property is removed from all elements of types.
 * - (210) (not for 'keepStructsAssocs'): Managed associations in GROUP BY and ORDER BY are
 *         replaced by by their foreign key fields.
 * - (220) Contexts that contain no artifacts or only ignored artifacts are ignored.
 * - (230) (only for 'keepStructsAssocs'): The following are rejected in views
 *         (a) Structured elements
 *         (b) Managed association elements
 *         (c) Managed association entries in GROUP BY
 *         (d) Managed association entries in ORDER BY
 * - (240) All artifacts (a), elements, foreign keys, parameters (b) that have a DB representation are annotated
 *         with their database name (as '@cds.persistence.name') according to the naming convention chosen
 *         in 'options.forHana.names'.
 * - (250) Remove name space definitions again (only in forHanaNew). Maybe we can omit inserting namespace definitions
 *         completely (TODO)
 *
 * @param {CSN.Model}   inputModel
 * @param {CSN.Options} options
 */
function transformForHanaWithCsn(inputModel, options) {
  // Used to control that we only initialized Draft stuff once
  // - see initDraft for details
  let draftIsInitialized = false;
  const draftSuffix = isDeprecatedEnabled(options, 'generatedEntityNameWithUnderscore') ? '_drafts' : '.drafts';
  const columnClearer = [];
  // copy the model as we don't want to change the input model
  timetrace.start('HANA transformation');
  /** @type {CSN.Model} */
  let csn = cloneCsn(inputModel, options);

  reclassifyWarnings(options);

  // Throw up if we have errors
  handleMessages(csn, options);

  // All services of the model - needed for drafts
  const allServices = getServiceNames(inputModel);

  checkCSNVersion(csn, options);

  const pathDelimiter = (options.forHana.names === 'hdbcds') ? '.' : '_';

  let error, warning, info, // message functions
    artifactRef, inspectRef, queryOrMain, effectiveType, // csnRefs
    addDefaultTypeFacets, resolvePath, flattenPath, expandStructsInOnConditions, toFinalBaseType, getFinalBaseType; // transformUtils

  bindCsnReference();

  const dialect = options.forHana && options.forHana.dialect || options.toSql && options.toSql.dialect;
  const doA2J = !options.forHana.keepStructsAssocs;
  if (!doA2J)
    forEachDefinition(csn, handleMixinOnConditions);

  // Run validations on CSN - each validator function has access to the message functions and the inspect ref via this
  const cleanup = validate.forHana(csn, {
    error, warning, info, inspectRef, effectiveType, artifactRef, csnUtils: getUtils(csn), csn, options, getFinalBaseType, isAspect
  });

  // Check if structured elements and managed associations are compared in an ON condition
  // and expand these structured elements. This tuple expansion allows all other
  // subsequent procession steps (especially a2j) to see plain paths in ON conditions.
  // If errors are detected, handleMessages will return from further processing

  forEachDefinition(csn, expandStructsInOnConditions);

  // Throw up if we have errors
  handleMessages(csn, options);

  // FIXME: This does something very similar to cloneWithTransformations -> refactor?
  const transformCsn = transformUtils.transformModel;

  // (001) Add a temporal where condition to views where applicable before assoc2join
  //       assoc2join eventually rewrites the table aliases
  forEachDefinition(csn, addTemporalWhereConditionToView);
  // Make sure that all source artifacts and association targets reach the database
  // (otherwise the view can't be activated), but only if the source artifact is NOT activated against the database
  forEachDefinition(csn, checkViewsForNoDB);

 // check unique constraints - further processing is done in rewriteUniqueConstraints`
  forEachDefinition(csn, handleAssertUnique);

  // Remove properties attached by validator - they do not "grow" as the model grows.
  cleanup();

  // (010) If requested, translate associations to joins
  if (doA2J)
    handleAssocToJoins();


  const redoProjections = [];
  forEachDefinition(csn, (artifact) => {
    if(artifact.kind === 'entity' && artifact.projection) {
      artifact.query = { SELECT: artifact.projection };
      delete artifact.projection;
      redoProjections.push(() => {
        if(artifact.query) {
          artifact.projection = artifact.query.SELECT;
          delete artifact.query;
          if(artifact.$syntax === 'projection') {
            delete artifact.$syntax;
          }
        }
      })
    } else if(artifact.kind === 'annotation' || artifact.kind === 'action' || artifact.kind === 'function' || artifact.kind === 'event'){
      // _ignore actions etc. - this loop seemed handy for this, as we can hook into an existing if
      artifact._ignore = true;
    }
  });

  const {
    flattenStructuredElement, checkForeignKeys,
    flattenStructStepsInRef, createForeignKeyElement, getForeignKeyArtifact,
    isAssociationOperand, isDollarSelfOrProjectionOperand,
    createAndAddDraftAdminDataProjection, createScalarElement, createAssociationElement,
    addElement, copyAndAddElement, createAssociationPathComparison,
    extractValidFromToKeyElement, checkAssignment, checkMultipleAssignments,
    recurseElements
  } = transformUtils.getTransformers(csn, options, pathDelimiter);

  const {
    getCsnDef,
    isAssocOrComposition,
    isComposition,
    isManagedAssociationElement,
    isStructured,
    addStringAnnotationTo,
    cloneWithTransformations,
    getFinalType,
  } = getUtils(csn);

  // (000) Rename primitive types, make UUID a String
  transformCsn(csn, {
    type: (val, node, key, path) => {
      // Resolve type-of chains
      function fn() {
        if (val.ref) {
          const { art } = inspectRef(path);
          if (art && art.type) {
            val = art.type;
            // This is somehow needed to update the ref so that inspectRef sees it
            node[key] = val;
            if (val.ref)
              fn();
          }
          else {
            // Doesn't seem to ever ocurr
          }
        }
      }
      fn();
      renamePrimitiveTypesAndUuid(val, node, key);
      addDefaultTypeFacets(node);
    },
    cast: (val) => {
      if (options.forHana.names === 'plain' || options.toSql )
        toFinalBaseType(val);
      renamePrimitiveTypesAndUuid(val.type, val, 'type');
      addDefaultTypeFacets(val);
    },
    // HANA/SQLite do not support array-of - turn into CLOB/Text
    items: (val, node) => {
      node.type = 'cds.LargeString';
      delete node.items;
    },
  }, true);

  // (030) - For all elements, replace derived types by final base type
  forEachDefinition(csn, (artifact) => {
    forEachMemberRecursively(artifact, (member) => {
      toFinalBaseType(member);
    });
  });

  // (040) Ignore entities and views that are abstract or implemented
  // or carry the annotation cds.persistence.skip/exists
  // These entities are not removed from the csn, but flagged as "to be ignored"
  forEachDefinition(csn, handleCdsPersistence);

  // (045) Strip all query-ish properties from views and projections annotated with '@cds.persistence.table',
  // and make them entities
  forEachDefinition(csn, handleQueryish);

  // Check for illegal usage of `array of` as table type
  forEachDefinition(csn, handleArrayOfCheck);
  // (050) Check @cds.valid.from/to only on entity
  //       Views are checked in (001), unbalanced valid.from/to's or mismatching origins
  //       Temporal only in beta-mode
  forEachDefinition(csn, handleTemporalAnnotations);

  // Basic flattening of views and entities
  // These steps need happen in isolation so that
  // the following step can rely on the rest of the model having
  // a certain structure, i.e. structs unfolded
  if(!options.forHana.keepStructsAssocs) {
    const flatteningOfStructured = [];
    const adaptRefs = [];
    // A2J resolves paths in queries to their flattened version,
    // that is the foreign key of a managed assoc that will be generated in a later step
    // we need to adapt the refs after the foreign keys are generated
    const adaptQueryRefLater = [];

    applyTransformations(csn, {
      ref: (parent, prop, ref, path) => {
        setProp(parent, '$path', [...path]);
        const lastRef = ref[ref.length-1];
        const fn = () => {
          const {scope} = inspectRef(parent.$path);
          const scopedPath = [...parent.$path];
          if(scope !== 'keys') {
            parent.ref = flattenStructStepsInRef(ref, scopedPath);
            // Explicitly set implicit alias for things that are now flattened - but only in columns
            if (parent.ref[ref.length - 1] != lastRef && insideColumns(scopedPath) && !parent.as)
              parent.as = lastRef;
          }
        };
        // adapt queries later
        const enclosingArtifact = csn.definitions[path[1]];
        if(enclosingArtifact.query)
          adaptQueryRefLater.push(fn);
        else
          adaptRefs.push(fn);

      }
    }, [(definitions, artifactName, artifact) => flatteningOfStructured.push(() => flattenStructuredElements(artifact, artifactName))]);

    adaptRefs.forEach(fn => fn());
    flatteningOfStructured.forEach(fn => fn());
    handleManagedAssociationsAndCreateForeignKeys();
    // now the foreign key references in queries are resolvable
    adaptQueryRefLater.forEach(fn => fn());
  }else {
    handleManagedAssociationsAndCreateForeignKeys();
  }

  function handleManagedAssociationsAndCreateForeignKeys(){
    forEachDefinition(csn, (art, artName) => handleManagedAssociationFKs(art, artName));
    forEachDefinition(csn, (art, artName) => createForeignKeyElements(art, artName));
  }

  forEachDefinition(csn, flattenIndexes);
  // Basic handling of associations in views and entities
  forEachDefinition(csn, handleAssociations);

  // Allow using managed associations as steps in on-conditions to access their fks
  // To be done after handleAssociations, since then the foreign keys of the managed assocs
  // are part of the elements
  forEachDefinition(csn, handleManagedAssocStepsInOnCondition);

  // Create convenience views for localized entities/views.
  // To be done after handleManagedAssocStepsInOnCondition because associations are
  // handled and before handleDBChecks which removes the localized attribute.
  // Association elements of localized convenience views do not have hidden properties
  // like $managed set, so we cannot do this earlier on.
  if (doA2J)
    addLocalizationViewsWithJoins(csn, options);
  else
    addLocalizationViews(csn, options);

  // For generating DB stuff:
  // - table-entity with parameters: not allowed
  // - view with parameters: ok on HANA, not allowed otherwise
  // (don't complain about action/function with parameters)
  forEachDefinition(csn, handleChecksForWithParameters);

  // Remove .masked
  // Check that keys are not explicitly nullable
  // Check that Associations are not used in entities/views with parameters
  forEachDefinition(csn, handleDBChecks);

  // (170) Transform '$self' in backlink associations to appropriate key comparisons
  // Must happen before draft processing because the artificial ON-conditions in generated
  // draft shadow entities have crooked '_artifact' links, confusing the backlink processing.
  // But it must also happen after flattenForeignKeys has been called for all artifacts,
  // because otherwise we would produce wrong ON-conditions for the keys involved. Sigh ...
  forEachDefinition(csn, transformSelfInBacklinks);

  if(isBetaEnabled(options, 'foreignKeyConstraints') && options.forHana)
    // no constraints for to-hdbcds.hdbcds as the managed associations are not resolved into their fks
    if(!(options.toHana && options.toHana.names === 'hdbcds'))
      createReferentialConstraints(csn, options);

  // (015) Generate artificial draft shadow entities if requested
  // Note that this needs to happen after implicit redirection has been performed, because it checks
  // for all draft nodes (additional artifacts reachable via compositions) to be part of a service.
  // This is typically achieved only by means of implicit redirection.
  forEachDefinition(csn, generateDraft);

   // Set the final constraint paths and produce hana tc indexes if required
   // See function comment for extensive information.
  forEachDefinition(csn, rewriteUniqueConstraints);

  // Some transformation for all kinds of artifacts
  // (240 a) Annotate artifacts with their DB names
  // Skip artifacts that have no DB equivalent anyway
  // FIXME: Ideally, we could do this on-the-fly while processing artifacts, but because we do struct
  // flattening etc non-recursively, we need to wait till all artifacts are processed
  forEachDefinition(csn, applyCommon);

  // (150 b) Strip inheritance
  // Note that this should happen after implicit redirection, because includes are required for that
  forEachDefinition(csn, (artifact) => {
    if (artifact.includes)
      delete artifact.includes;
  });

  // Associations that point to thins marked with @cds.persistence.skip are removed
  forEachDefinition(csn, ignoreAssociationToSkippedTarget);

  // Apply view-specific transformations
  // (160) Projections now finally become views
  forEachDefinition(csn, transformViews);

  // (210) Fix GROUP BY, ORDER BY in views
  forEachDefinition(csn, replaceAssociationsInGroupByOrderBy);

  // Recursively apply transformCommon and attach @cds.persistence.name
  forEachDefinition(csn, recursivelyApplyCommon);

  // (20 a) If we keep associations as they are (hdbcds naming convention), we cannot have structured
  // view elements (we could enumerate the elements but we can't give them the names one would expect)
  // Check foreign keys of redirected associations
  // (200) Strip 'key' property from type elements
  forEachDefinition(csn, recursiveChecks);

  const checkConstraintIdentifiers = (artifact, artifactName, prop, path) => {
    assertConstraintIdentifierUniqueness(artifact, artifactName, path, error);
  };
  const removeNamespaces = (artifact, artifactName) => {
    if (artifact.kind === 'namespace')
      delete csn.definitions[artifactName];
  };
  const ignoreNonPersistedArtifactsWithAnonymousAspectComposition = (artifact) => {
    if(artifact.kind === 'type' || artifact.kind === 'aspect' || artifact.kind === 'entity' && artifact.abstract){
      if(artifact.elements && Object.keys(artifact.elements).some((elementName) => {
        const element = artifact.elements[elementName];
        return !element.target && element.targetAspect && typeof element.targetAspect !== 'string';
      })) {
        artifact._ignore = true;
      }
    }
  };

  forEachDefinition(csn, [
    /* assert that there will be no conflicting unique- and foreign key constraint identifiers */
    checkConstraintIdentifiers,
    /* (250) Remove all namespaces from definitions */
    removeNamespaces,
    /* (190 b) Replace enum types by their final base type */
    replaceEnumsByBaseTypes,
    /* Check Type Parameters (precision, scale, length ...) */
    checkTypeParameters,
    /* Filter out aspects/types/abstract entities containing managed compositions of anonymous aspects */
    ignoreNonPersistedArtifactsWithAnonymousAspectComposition
  ]);

  // Throw up if we have errors
  handleMessages(csn, options);

  timetrace.stop();

  function killProp(parent, prop){
    delete parent[prop];
  }

  const killers = {
    '_ignore': function (parent, a, b, path){
      if(path.length > 2) {
        const tail = path[path.length-1];
        const parentParent = walkCsnPath(path.slice(0, -1));
        delete parentParent[tail];
      } else {
        delete parent._ignore;
      }
    },
    '_art': killProp,
    '_effectiveType': killProp,
    '_flatElementNameWithDots': killProp,
    '_sources': killProp,
    '$default': killProp,
    '$draftRoot': killProp,
    '$env': killProp,
    '$fksgenerated': killProp,
    '$lateFlattening': killProp,
    '$path': killProp,
    '$renamed': killProp,
    '$key': killProp
  }

  applyTransformations(csn, killers, [], false);

  redoProjections.forEach(fn => fn());
  columnClearer.forEach(fn => fn());

  return csn;

  /* ----------------------------------- Functions start here -----------------------------------------------*/
  /**
   * Create the foreign key elements for managed associations.
   * Create them in-place, right after the corresponding association.
   *
   *
   * @param {CSN.Artifact} art
   * @param {string} artName
   */
  function createForeignKeyElements(art, artName) {
    if ((art.kind === 'entity' || art.kind === 'view') && !options.forHana.keepStructsAssocs) {
      forAllElements(art, artName, (parent, elements, pathToElements) => {
        const elementsArray = [];
        forEachGeneric(parent, 'elements', (element, elemName) => {
          elementsArray.push([elemName, element]);
          if (isManagedAssociationElement(element)) {
            if (element.keys) {
              for(let i = 0; i < element.keys.length; i++){
                const foreignKey = element.keys[i];
                const path =  [...pathToElements, elemName, 'keys', i];
                foreignKey.ref = flattenStructStepsInRef(foreignKey.ref, path);
                const [fkName, fkElem] = getForeignKeyArtifact(element, elemName, foreignKey, path);
                if(parent.elements[fkName]) {
                  error(null, [...pathToElements, elemName], { name: fkName, art: elemName },
                       'Generated foreign key element $(NAME) for association $(ART) conflicts with existing element');
                } else {
                  elementsArray.push([fkName, fkElem]);
                }
                applyCachedAlias(foreignKey);
                // join ref array as the struct / assoc steps are not necessary anymore
                foreignKey.ref = [foreignKey.ref.join(pathDelimiter)]
              }
            }
          }
        });

        // Don't fake consistency of the model by adding empty elements {}
        if(elementsArray.length === 0)
          return;

        parent.elements = elementsArray.reduce((previous, [name, element]) => {
          previous[name] = element;
          return previous;
        }, Object.create(null));

      })
    }

    function applyCachedAlias(foreignKey) {
      // If we have a $ref use that - it resolves aliased FKs correctly
      if (foreignKey.$ref) {
        foreignKey.ref = foreignKey.$ref;
        delete foreignKey.$ref;
      }
    }
  }


  function bindCsnReference(){
    ({ artifactRef, inspectRef, queryOrMain, effectiveType } = csnRefs(csn));
    ({ getFinalBaseType } = getUtils(csn));
    ({ addDefaultTypeFacets, resolvePath, flattenPath, expandStructsInOnConditions, toFinalBaseType } = transformUtils.getTransformers(csn, options, pathDelimiter));
    ({ error, warning, info } = makeMessageFunction(csn, options, 'to.hana'));
  }

  function handleMixinOnConditions(artifact, artifactName) {
    if (!artifact.query)
      return;
    forAllQueries(artifact.query, (query, path) => {
      const { mixin } = query.SELECT  || {};
      if(mixin) {
        query.SELECT.columns
        // filter for associations which are used in the SELECT
        .filter((c) => {
          return c.ref &&  c.ref.length > 1;
        })
        .map((usedAssoc) => {
          const assocName = pathId(usedAssoc.ref[0]);
          const mixinAssociation = mixin[assocName];
          if(mixinAssociation){
            mixinAssociation.on = getResolvedMixinOnCondition(csn, mixinAssociation, query, assocName, path.concat(['mixin', assocName]));
          }
        })
      }
    }
    , [ 'definitions', artifactName, 'query' ]);
    function getResolvedMixinOnCondition(csn, mixinAssociation, query, assocName, path){
      let { inspectRef } = csnRefs(csn);
      return mixinAssociation.on
            .map((onConditionPart, i) => {
              let columnToReplace;
              if(onConditionPart.ref && (onConditionPart.ref[0] === '$projection' || onConditionPart.ref[0] === '$self')){
                const { links } = inspectRef(path.concat(['on', i]));
                if(links){
                  // no assocs in $projection / $self paths #5050
                  links.forEach((element, j) => {
                    const { art } = links[j];
                    if(art && art.target) // Fine for plain
                      error(null, path.concat(['on', j]), `Step "${onConditionPart.ref[j]}" in path "${onConditionPart.ref.join('.')}" must not be an association`);
                  });
                  columnToReplace = onConditionPart.ref[links.length - 1];
                }
              }
              const replaceWith = query.SELECT ? query.SELECT.columns
              .find((column) => column.as && column.as === columnToReplace || column.ref && column.ref[0] === columnToReplace ) :
              null;

              // No implicit CAST in on-condition
              if(replaceWith && replaceWith.cast) {
                const clone = cloneCsn(replaceWith, options);
                delete clone.cast;
                return clone;
              }
              return replaceWith || onConditionPart;
            });
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   * @param {string} property
   * @param {CSN.Path} path
   */
  function applyCommon(artifact, artifactName, property, path) {
    if (!artifact._ignore) {
      transformCommon(artifact, artifactName, path);

      if (![ 'service', 'context', 'namespace', 'annotation', 'action', 'function' ].includes(artifact.kind))
        addStringAnnotationTo('@cds.persistence.name', getArtifactDatabaseNameOf(artifactName, options.forHana.names, csn), artifact);
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function transformViews(artifact, artifactName) {
    if (!artifact._ignore) {
      // Do things specific for entities and views (pass 2)
      if ((artifact.kind === 'entity' || artifact.kind === 'view') && artifact.query) {
        forAllQueries(artifact.query, (q, p) => transformEntityOrViewPass2(q, artifact, artifactName, p)
          , [ 'definitions', artifactName, 'query' ]);
      }
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function recursivelyApplyCommon(artifact, artifactName) {
    if (!artifact._ignore) {
      forEachMemberRecursively(artifact, (member, memberName, property, path) => {
        transformCommon(member, memberName, path);
        // (240 b) Annotate elements, foreign keys, parameters etc with their DB names
        // Virtual elements in entities and types are not annotated, as they have no DB representation.
        // In views they are, as we generate a null expression for them (null as <colname>)
        if ((!member.virtual || artifact.query))
          addStringAnnotationTo('@cds.persistence.name', getElementDatabaseNameOf(memberName, options.forHana.names), member);
      }, [ 'definitions', artifactName ]);
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function recursiveChecks(artifact, artifactName) {
    if (!artifact._ignore) {
      forEachMemberRecursively(artifact, (member, memberName, property, path) => {
        if (options.forHana.keepStructsAssocs &&
          artifact.query &&
          isStructured(member)) {
          error(null, path, `With "hdbcds" naming, structured elements can't be used in a view`);
          return;
        }
        if (!member._ignore && isAssocOrComposition(member.type))
          checkForeignKeys(member, memberName, artifactName, options);

        if (artifact.kind === 'type' && member.key)
          delete member.key;
      }, [ 'definitions', artifactName ]);
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function replaceEnumsByBaseTypes(artifact, artifactName) {
    replaceEnumByBaseType(artifact);
    forEachMemberRecursively(artifact, (member) => {
      replaceEnumByBaseType(member);
      if (options.forHana.alwaysResolveDerivedTypes || options.forHana.names === 'plain') {
        toFinalBaseType(member);
        addDefaultTypeFacets(member);
      }
    }, [ 'definitions', artifactName ]);
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function generateDraft(artifact, artifactName) {
    if ((artifact.kind === 'entity' || artifact.kind === 'view') && hasBoolAnnotation(artifact, '@odata.draft.enabled')) {
      // Ignore if not part of a service
      if (!isPartOfService(artifactName)) {
        warning(null, [ 'definitions', artifactName ], `Ignoring annotation "@odata.draft.enabled" - artifact "${ artifactName }" is not part of a service`);
        return;
      }

      // Determine the set of target draft nodes belonging to this draft root (the draft root
      // itself plus all its transitively composition-reachable targets)
      const draftNodes = Object.create(null);
      collectDraftNodesInto(artifact, artifactName, artifact, draftNodes);
      // Draft-enable all of them
      for (const name in draftNodes)
        generateDraftForHana(draftNodes[name], name, artifactName);


      if (draftNodes) {
        initDraft();
      }
      // Redirect associations/compositions between draft shadow nodes
      for (const name in draftNodes) {
        const shadowNode = csn.definitions[`${ name }${draftSuffix}`];
        // Might not exist because of previous errors
        if (shadowNode)
          redirectDraftTargets(csn.definitions[`${ name }${draftSuffix}`], draftNodes);
      }
    }
  }

  function initDraft() {
    if(!draftIsInitialized && csn.definitions['DRAFT.DraftAdministrativeData']) {
      transformCsn(csn.definitions['DRAFT.DraftAdministrativeData'], {
        type: (val, node, key) => {
          renamePrimitiveTypesAndUuid(val, node, key);
          addDefaultTypeFacets(node);
        },
        cast: (val) => {
          if (options.forHana.names === 'plain')
            toFinalBaseType(val);
          renamePrimitiveTypesAndUuid(val.type, val, 'type');
          addDefaultTypeFacets(val);
        },
      });

      draftIsInitialized = true;
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function transformSelfInBacklinks(artifact, artifactName, dummy, path) {
    // Fixme: For toHana mixins must be transformed, for toSql -d hana
    // mixin elements must be transformed, why can't toSql also use mixins?
    doit(artifact.elements, path.concat([ 'elements' ]));
    if (artifact.query && artifact.query.SELECT && artifact.query.SELECT.mixin)
      doit(artifact.query.SELECT.mixin, path.concat([ 'query', 'SELECT', 'mixin' ]));

    function doit(dict, subPath) {
      for (const elemName in dict) {
        const elem = dict[elemName];
        if (isAssocOrComposition(elem.type) && elem.on)
          processBacklinkAssoc(elem, elemName, artifact, artifactName, subPath.concat([ elemName, 'on' ]));
      }
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleDBChecks(artifact, artifactName) {
    // Process the artifact's  members
    forEachMemberRecursively(artifact, (member, memberName, prop, path) => {
      // (100 a) Ignore the property 'masked' itself (but not its effect on projections)
      if (member.masked)
        delete member.masked;
      // Report an error if a key is explicitly (!) nullable
      if (member.key && member.notNull === false) // Weird - looks like it is run for to.hdbcds and also to.sql?!
        error(null, path, `Key elements can't be nullable in SAP HANA CDS`);


      // For HANA: Report an error on
      // - view with parameters that has an element of type association/composition
      // - association that points to entity with parameters
      if (options.forHana.dialect === 'hana' && member.target && isAssocOrComposition(member.type) && !isBetaEnabled(options, 'assocsWithParams')) {
        if (artifact.params) {
          // HANA does not allow 'WITH ASSOCIATIONS' on something with parameters:
          // SAP DBTech JDBC: [7]: feature not supported: parameterized sql view cannot support association: line 1 col 1 (at pos 0)
          error(null, path, `Associations are not allowed in entities with parameters`);
        }
        else if(artifact['@cds.persistence.udf'] || artifact['@cds.persistence.calcview']) {
          // UDF/CVs w/o params don't support 'WITH ASSOCIATIONS'
          error(null, path, `Associations are not allowed in entities annotated with @cds.persistence { udf, calcview }`);
        }
        if (csn.definitions[member.target].params) {
          // HANA does not allow association targets with parameters or to UDFs/CVs w/o parameters:
          // SAP DBTech JDBC: [7]: feature not supported: cannot support create association to a parameterized view
          error(null, path, `Associations can't point to entities with parameters`);
        }
        else if(csn.definitions[member.target]['@cds.persistence.udf'] || artifact['@cds.persistence.calcview']) {
          // HANA won't check the assoc target but when querying an association with target UDF, this is the error:
          // SAP DBTech JDBC: [259]: invalid table name: target object SYSTEM.UDF does not exist: line 3 col 6 (at pos 43)
          // CREATE TABLE F (id INTEGER NOT NULL);
          // CREATE FUNCTION UDF RETURNS TABLE (ID INTEGER) LANGUAGE SQLSCRIPT SQL SECURITY DEFINER AS BEGIN RETURN SELECT ID FROM F; END;
          // CREATE TABLE Y (  id INTEGER NOT NULL,  toUDF_id INTEGER) WITH ASSOCIATIONS (MANY TO ONE JOIN UDF AS toUDF ON (toUDF.id = toUDF_id));
          // CREATE VIEW U AS SELECT  id, toUDF.a FROM Y;
          error(null, path, `Associations can't point to entities annotated with @cds.persistence { udf, calcview }`);
        }
      }
    }, [ 'definitions', artifactName ]);
  }

  /**
   *
   * Generate foreign keys for managed associations
   * Forbid aliases for foreign keys
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleAssociations(artifact, artifactName) {
    // Do things specific for entities and views (pass 1)
    if (artifact.kind === 'entity' || artifact.kind === 'view') {
      forAllElements(artifact, artifactName, (parent, elements) => {
        for (const elemName in elements) {
          const elem = elements[elemName];
          // (140) Generate foreign key elements and ON-condition for managed associations
          // (unless explicitly asked to keep assocs unchanged)
          if (!options.forHana.keepStructsAssocs) {
            if (isManagedAssociationElement(elem))
              transformManagedAssociation(parent, artifactName, elem, elemName);
          }
        }
      })
    }
  }

  function fixBorkedElementsOfLocalized(elements, pathToElements){
    const pathToNonLocalized = ['definitions', pathToElements[1].replace('localized.',''), ...pathToElements.slice(2)];
    const nonLocalizedElements = walkCsnPath(pathToNonLocalized);


    for(const elementName in elements){
      const element = elements[elementName];
      const reference = nonLocalizedElements[elementName];

      // if the declared element is an enum, these values are with priority
      if (!element.enum && reference.enum)
        Object.assign(element, { enum: reference.enum });
      if (!element.length && reference.length && !reference.$default)
        Object.assign(element, { length: reference.length });
      if (!element.precision && reference.precision)
        Object.assign(element, { precision: reference.precision });
      if (!element.scale && reference.scale)
        Object.assign(element, { scale: reference.scale });
      if (!element.srid && reference.srid)
        Object.assign(element, { srid: reference.srid });
      if (!element.keys && reference.keys)
        Object.assign(element, { keys: cloneCsn(reference.keys, options)})
      if (!element.type && reference.type)
        Object.assign(element, { type: reference.type})
      if (!element.on && reference.on && !reference.keys)
        Object.assign(element, {on: cloneCsn(reference.on, options)})
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleChecksForWithParameters(artifact, artifactName) {
    if (!artifact._ignore && artifact.params && (artifact.kind === 'entity' || artifact.kind === 'view')) {
      if (!artifact.query) { // table entity with params
        // Allow with plain
        error(null, [ 'definitions', artifactName ], { '#': options.toSql ? 'sql' : 'std' }, {
          std: 'Table-like entities with parameters are not supported for conversion to SAP HANA CDS',
          sql: 'Table-like entities with parameters are not supported for conversion to SQL',
        });
      }
      else if (options.forHana.dialect === 'sqlite') { // view with params
        // Allow with plain
        error(null, [ 'definitions', artifactName ], `SQLite does not support entities with parameters`);
      }
      else {
        for (const pname in artifact.params) {
          if (pname.match(/\W/g) || pname.match(/^\d/) || pname.match(/^_/)) { // parameter name must be regular SQL identifier
            warning(null, [ 'definitions', artifactName, 'params', pname ], `"${ artifactName }", parameter "${ pname }": is not a regular SQL identifier`);
          }
          else if (options.forHana.names !== 'plain' && pname.toUpperCase() !== pname) { // not plain mode: param name must be all upper
            warning(null, [ 'definitions', artifactName, 'params', pname ], `"${ artifactName }", parameter "${ pname }": in naming mode "${ options.forHana.names }" parameter names must be all uppercase`);
          }
        }
      }
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleArrayOfCheck(artifact, artifactName) {
    // (050) Checks on the hierarchical csn (pre-flattening)
    if (artifact.kind === 'entity' && !artifact.query) {
      // only loop over the top-level members -> We do the recursive checking in the checkForArrayOf function.
      forEachMember(artifact, (member, memberName) => {
        checkForArrayOf(artifact, artifactName, member, memberName);
      });
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleQueryish(artifact, artifactName) {
    const stripQueryish = artifact.query && hasBoolAnnotation(artifact, '@cds.persistence.table');

    if (stripQueryish) {
      artifact.kind = 'entity';
      delete artifact.query;
    }

    recurseElements(artifact, [ 'definitions', artifactName ], (member, path) => {
      // All elements must have a type for this to work
      if (stripQueryish && !member.kind && !member.type)
        error(null, path, `All elements must have a type when entity is annotated with "@cds.persistence.table"`);
    });
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleCdsPersistence(artifact, artifactName) {
    if (artifact.kind === 'entity' || artifact.kind === 'view') {
      if (artifact.abstract
        || hasBoolAnnotation(artifact, '@cds.persistence.skip')
        || hasBoolAnnotation(artifact, '@cds.persistence.exists'))
        artifact._ignore = true;

      // issue #3450 HANA CDS can not handle external artifacts which are part of a HANA CDS context
      if (options.forHana.names === 'quoted' &&
          hasBoolAnnotation(artifact, '@cds.persistence.exists')) {
        const firstPath = artifactName.split('.')[0];
        const topParent = csn.definitions[firstPath];
        // namespaces, contexts and services become contexts in HANA CDS
        if (topParent && [ 'namespace', 'context', 'service' ].includes(topParent.kind))
          warning(null, [ 'definitions', artifactName ], `"${ artifactName }": external definition belongs to ${ topParent.kind } "${ firstPath }"`);
      }
    }
  }

  function handleAssocToJoins() {
    // the augmentor isn't able to deal with technical configurations and since assoc2join can ignore it we
    // simply make it invisible and copy it over to the result csn
    forEachDefinition(csn, art => art.technicalConfig && setProp(art, 'technicalConfig', art.technicalConfig));
    const newCsn = translateAssocsToJoinsCSN(csn, options);
    // console.log(JSON.stringify(newCsn,null,2))

    // restore all (non-enumerable) properties that wouldn't survive reaugmentation/compactification into the new compact model
    forEachDefinition(csn, (art, artName) => {
      if(art['$tableConstraints']) {
        setProp(newCsn.definitions[artName], '$tableConstraints', art['$tableConstraints']);
      }
      if (art.technicalConfig)
        newCsn.definitions[artName].technicalConfig = art.technicalConfig;

      const newArt = newCsn.definitions[artName];

      // No need to loop/check artifacts that won't reach the DB anyways
      if (art.query && newArt && newArt.query && isPersistedOnDatabase(newArt)) {
        // Loop through the newCSN and add possible new _ignore mixin to the kill list
        forAllQueries(newArt.query, (q, p) => {
          if (q.SELECT && q.SELECT.mixin) {
            for(let mixinName of Object.keys(q.SELECT.mixin)) {
              const mixinElement = q.SELECT.mixin[mixinName];
              if (mixinElement._ignore && options.toSql) {
                columnClearer.push(() => {
                  const query = walkCsnPath(p);
                  for(let i = query.columns.length-1; i > -1; i--){
                    const col = query.columns[i];
                    if(col && col.ref && col.ref[0] === mixinName){
                      query.columns.splice(i, 1);
                    }
                  }
                });
              }
            }
          }
        }, ['definitions', artName, 'query']);
      }
    });
    csn = newCsn;
    bindCsnReference();
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function checkViewsForNoDB(artifact, artifactName) {
    // Make sure that all source artifacts and association targets reach the database
    // (otherwise the view can't be activated), but only if the source artifact is NOT activated against the database
    if (isPersistedOnDatabase(artifact) && !hasBoolAnnotation(artifact, '@cds.persistence.table') && getNormalizedQuery(artifact).query) {
      forAllQueries(getNormalizedQuery(artifact).query, (query, path) => {
        checkQueryForNoDBArtifacts(query.SELECT || query.SET, path);
      }, [ 'definitions', artifactName, artifact.projection ? 'projection': 'query' ]);
    }
  }

  /**
   * Check unique constraint paths
   * Render secondary indexes in technical configuration for hdbcds
   * Path flattening is done in TC index code: Must expand foreign keys
   * Must run before items are retyped to cds.LargeString, otherwise
   * items error detection becomes impossible
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleAssertUnique(artifact, artifactName) {
    // operate only on real entities that are not abstract
    if(artifact.abstract || (artifact.kind !== 'entity' || (artifact.query || artifact.projection) && !hasBoolAnnotation(artifact, '@cds.persistence.table')))
      return;
    let constraintXrefs = Object.create(null);
    let constraintDict = Object.create(null);
    // filter unique constraints from annotations
    for(const propName in artifact) {
      if(propName.startsWith('@assert.unique') && artifact[propName] !== null) {
        // Constraint Name check
        const constraintName = propName.split('.').splice(2);
        if(constraintName.length === 0)
          err(propName, 'Table constraint cannot be anonymous');
        if(constraintName.length > 1)
          // Neither HANA CDS nor HANA SQL allow dots in index names
          err(propName, "Illegal character '.' in constraint name");

        const propValue = artifact[propName];
        // Constraint value check, returns array of path values
        const pathValues = checkVal(propValue, propName);

        // 1) Convert each path string into a path object with ref array.
        // 2) Resolve path ref array and store resolved artifact in refs and path object
        // 3) Flatten all paths that end on a structured type
        // 4) Collect all path object in paths array
        let pathObjects = pathValues.map(v=>resolvePath(toRef(v), artifact));
        // 5) Check each path step of each unflattened path,
        //    This avoids duplicate errors on same path step
        pathObjects.forEach(p=>check(p, propName));
        // 6) Remove paths without final _art from further processing including
        //    path rewriting in rewriteUniqueConstraints
        pathObjects = pathObjects.filter(p=>p._art);
        // 7) Flatten correct paths, check and clean again
        let flattenedPathObjects = [];
        pathObjects.forEach(p=>flattenedPathObjects.push(...flattenPath(p, true)))
        flattenedPathObjects.forEach(p=>check(p, propName));
        flattenedPathObjects = flattenedPathObjects.filter(p=>p._art);
        // 8) Duplicate path check on final flattened paths to detect structural overlaps
        const pathxrefs = Object.create(null);
        // constraintKey is the concatenation of all flattened paths (order is important)
        let constraintKey = '';
        flattenedPathObjects.forEach(p => {
          const pstr = p.ref.map(p=>p.id).join('.');
          constraintKey += pstr;
          if(!pathxrefs[pstr])
            pathxrefs[pstr] = 1;
          else
            pathxrefs[pstr]++;
        });
        Object.keys(pathxrefs).forEach(k => {
          if(pathxrefs[k] > 1)
            err(propName, `Final path "${k}" can only be specified once`);
        });
        // 9) Add into constraint cross reference
        if(constraintKey.length) {
          if(constraintXrefs[constraintKey])
            constraintXrefs[constraintKey].push(propName);
          else
          constraintXrefs[constraintKey] = [ propName ];
        }
        // 10) Store remaining paths (if any) in constraint dictionary
        if(flattenedPathObjects.length)
          constraintDict[constraintName.join('.')] = flattenedPathObjects;
      }
    }

    // 11) Duplicate constraint check
    for(const key in constraintXrefs) {
      const val = constraintXrefs[key];
      if(val.length > 1)
        err(val.join(', '), 'Constraint can only be specified once')
    }
    // preserve dictionary in '$tableConstraints' on the artifact for path rewriting and rendering
    if(Object.keys(constraintDict).length){
      if(!('$tableConstraints' in artifact))
        setProp(artifact, '$tableConstraints', Object.create(null));

      setProp(artifact.$tableConstraints, 'unique', constraintDict);
    }

    /*
     * Check strictly that annotation value is an array
     * and that the individual array entries are references
     * Return array of paths
     */
    function checkVal(val, propName) {
      let paths = [];
      if(!Array.isArray(val)) {
        err(propName, `Value '${JSON.stringify(unref(val))}' is not an array`);
      }
      else {
        if(val.length === 0)
          inf(propName, 'Empty annotation is ignored');

        val.forEach(v => {
          let p = v['='];
          if(!p)
            err(propName, `Value '${JSON.stringify(unref(v))}' is not a path`);
          else {
            paths.push(p);
          }
        });
      }
      return paths;

      function unref(v) {
        if(Array.isArray(v))
          return v.map(unref);
        return (v['='] || v)
      }
    }

    /*
     * convert a path string to a ref object and pop $self/$projection
     */
    function toRef(val) {
      let ref = val.split('.');
      const [ head, ...tail ] = ref;
      if([ '$self', '$projection' ].includes(head))
        ref = tail;
      return {
        ref: ref.map(ps => {
          const o=Object.create(null);
          o.id = ps;
          return o;
        })
      };
    }

    /**
     * Check resolved path
     * - no array of/many path step allowed
     * - must not end on unmanaged association/composition
     * - foreign key access is not allowed (hard to rewrite)
     * - type check for final type
     * - path steps with no _art link are 'not found'
     */
    function check(path, constraintName) {
      if(path.isChecked)
        return;
      path.isChecked = true;
      let foundErr = false;
      for(let i=0; i < path.ref.length && !foundErr; i++) {
        const art = path.ref[i]._art;
        if(art) {
          if(art.items) {
            msg(`'Array of/many' element "${path.ref[i].id}" is not allowed`);
            delete path._art;
            foundErr = true;
          }
          if(art.target) {
            if(art.on) {
              msg(`Unmanaged association "${path.ref[i].id}" is not allowed`);
              delete path._art;
              foundErr = true;
            }
            if(art.keys && i < path.ref.length-1) {
              msg(`Element access via managed association "${path.ref[i].id}" is not allowed`);
              delete path._art;
              foundErr = true;
            }
          }
        }
        else {
          err(constraintName, `"${path.ref[i].id}" has not been found`);
          foundErr = true;
        }
      }

      if(!foundErr && path._art && ['cds.LargeBinary', 'cds.LargeString',
        'cds.hana.CLOB', 'cds.hana.ST_POINT', 'cds.hana.ST_GEOMETRY'].includes(path._art.type)) {
        msg(`"Type ${path._art.type}" not allowed`);
      }

      function msg(msg) {
        err(constraintName, `${msg} in "${path.ref.map(p=>p.id).join('.')}"`);
      }
    }

    // message macros for unified messaging
    function err(propName, msg) {
      error(null, ['definitions', artifactName], `${propName}: ${msg}`);
    }
    function inf(propName, msg) {
      info(null, ['definitions', artifactName], `${propName}: ${msg}`);
    }
  }


  /*
   * rewriteUniqueConstraints adjusts the constraint paths
   * to the final output format.
   *
   * All paths in $tableConstraints.unique are supposed to be fully
   * resolved and correct constraint candidates.
   *
   * Paths that terminate on an association are replaced with the
   * foreign key paths that belong to this association.
   *
   * If the output format is HANA CDS, a technical configuration is
   * added and unique secondary indexes are created.
   *
   * If the output format is SQL, the toSql renderer is responsible
   * to render the table constraints from the constraint dictionary.
   *
   * If options.toHana, no path flattening is done and  association
   * paths are replaced with the foreign key paths by simply
   * concatenating the foreign key paths (available in element.keys).
   *
   * If options.toSql, all paths are flattened depending on the naming
   * mode either with '_' or '.' as delimiter.
   * Each association is replaced by the respective foreign key elements
   * that are annotated with an appropriate '@odata.foreignKey4'.
   */
  function rewriteUniqueConstraints(artifact) {
    let naming = options.forHana.names || options.toSql.names;
    if(artifact.$tableConstraints && artifact.$tableConstraints.unique) {
      const uniqueConstraints = artifact['$tableConstraints'].unique;
      // it's safe to add the tc here
      if(options.toHana) {
        if(!artifact.technicalConfig) {
          artifact.technicalConfig = Object.create(null);
        }
        if(!artifact.technicalConfig.hana) {
          artifact.technicalConfig.hana = Object.create(null);
          artifact.technicalConfig.hana.calculated = true;
        }
        if(!artifact.technicalConfig.hana.indexes)
          artifact.technicalConfig.hana.indexes = Object.create(null);
      }
      for(const uniqueConstraint in artifact.$tableConstraints.unique) {
        // iterate over each constraint
        const c = uniqueConstraints[uniqueConstraint];
        const rewrittenPaths = [];
        // and inspect each path of the constraint
        c.forEach(cpath => {
          // If 'toSql' or 'toHana' and naming !== 'hdbcds'
          // concatenate path refs with appropriate delimiter
          if(!options.toHana || (options.toHana && naming !== 'hdbcds'))
            cpath.ref = [ cpath.ref.map(p=>p.id).join( pathDelimiter ) ];

          // Foreign key substitution
          if(cpath._art.target) {
            if(!options.toHana || (options.toHana && naming !== 'hdbcds')) {
              // read out new association and use $generatedFieldName
              // cpath._art still refers to the assoc definition
              // before the A2J transformation. This assoc
              // doesn't contain the correct $generatedFieldName(s)
              const assoc = artifact.elements[cpath.ref[0]];
              rewrittenPaths.push(...assoc.keys.map(k => {
                return { ref: [ k.$generatedFieldName ] };
              }));
            }
            else {
              // This is Classic HANA CDS toHana/hdbcds
              // add foreign key ref path to association path
              // ... for hanacds, the 'real' ref paths are used, and
              // these have not changed before and after A2J transformation,
              // so it's safe to use the original paths.
              rewrittenPaths.push(...cpath._art.keys.map(k => {
                return { ref: cpath.ref.concat(k.ref) };
              }));
            }
          }
          else {
            rewrittenPaths.push(cpath);
          }
        });
        // preserve the rewritten and filtered paths for toSql
        uniqueConstraints[uniqueConstraint] = rewrittenPaths;

        // now add the index for HANA CDS
        if(options.toHana) {
          let index = [ 'unique', 'index', { ref: [ uniqueConstraint ] }, 'on', '(' ];
          let i = 0;
          for(let c of rewrittenPaths) {
            if(i>0)
              index.push(',');
            index.push(c);
            i++;
          }
          index.push(')');
          artifact.technicalConfig.hana.indexes[uniqueConstraint] = index;
        }
      }
      setProp(artifact.$tableConstraints, 'unique', uniqueConstraints)
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleTemporalAnnotations(artifact, artifactName) {
    const validFrom = [];
    const validTo = [];
    const validKey = [];

    recurseElements(artifact, [ 'definitions', artifactName ], (member, path) => {
      const [ f, t, k ] = extractValidFromToKeyElement(member, path);
      validFrom.push(...f);
      validTo.push(...t);
      validKey.push(...k);
    });

    if (artifact.kind === 'entity' && !artifact.query) {
      validFrom.forEach(obj => checkAssignment('@cds.valid.from', obj.element, obj.path, artifact));
      validTo.forEach(obj => checkAssignment('@cds.valid.to', obj.element, obj.path, artifact));
      validKey.forEach(obj => checkAssignment('@cds.valid.key', obj.element, obj.path, artifact));
      checkMultipleAssignments(validFrom, '@cds.valid.from', artifact, artifactName);
      checkMultipleAssignments(validTo, '@cds.valid.to', artifact, artifactName, true);
      checkMultipleAssignments(validKey, '@cds.valid.key', artifact, artifactName);
    }

    // if there is an cds.valid.key, make this the only primary key
    // otherwise add all cds.valid.from to primary key tuple
    if (validKey.length) {
      if (!validFrom.length || !validTo.length)
        error(null, [ 'definitions', artifactName ], `@cds.valid.key was used but @cds.valid.from and @cds.valid.to are missing`);

      forEachMember(artifact, (member) => {
        if (member.key) {
          member.unique = true;
          delete member.key;
          // Remember that this element was a key in the original artifact.
          // This is needed for localized convenience view generation.
          setProp(member, '$key', true);
        }
      });
      validKey.forEach((member) => {
        member.element.key = true;
      });

      validFrom.forEach((member) => {
        member.element.unique = true;
      });
    }
    else {
      validFrom.forEach((member) => {
        member.element.key = true;
      });
    }
  }

  /**
   * Add a where condition to views that
   * - are annotated with @cds.valid.from and @cds.valid.to,
   * - have only one @cds.valid.from and @cds.valid.to,
   * - and both annotations come from the same entity
   *
   * If the view has one of the annotations but the other conditions are not met, an error will be raised.
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function addTemporalWhereConditionToView(artifact, artifactName) {
    const normalizedQuery = getNormalizedQuery(artifact);
    if (normalizedQuery && normalizedQuery.query && normalizedQuery.query.SELECT) {
      // BLOCKER: We need information to handle $combined
      // What we are trying to achieve by this:
      // Forbid joining/selecting from two or more temporal entities
      // Idea: Follow the query-tree and check each from
      // Collect all source-entities and compute our own $combined
      const $combined = get$combined(normalizedQuery.query);
      const [ from, to ] = getFromToElements($combined);
      // exactly one validFrom & validTo
      if (from.length == 1 && to.length == 1) {
        // and both are from the same origin
        if (from[0].source === to[0].source && from[0].parent === to[0].parent) {
          const fromPath = {
            ref: [
              from[0].parent,
              from[0].name,
            ],
          };

          const toPath = {
            ref: [
              to[0].parent,
              to[0].name,
            ],
          };


          const atFrom = { ref: [ '$at', 'from' ] };
          const atTo = { ref: [ '$at', 'to' ] };

          const cond = [ '(', fromPath, '<', atTo, 'and', toPath, '>', atFrom, ')' ];

          if (normalizedQuery.query.SELECT.where) { // if there is an existing where-clause, extend it by adding 'and (temporal clause)'
            normalizedQuery.query.SELECT.where = [ '(', ...normalizedQuery.query.SELECT.where, ')', 'and', ...cond ];
          }
          else {
            normalizedQuery.query.SELECT.where = cond;
          }
        }
        else {
          info(null, [ 'definitions', artifactName ], `No temporal WHERE clause added as "${ from[0].error_parent }"."${ from[0].name }" and "${ to[0].error_parent }"."${ to[0].name }" are not of same origin`);
        }
      }
      else if (from.length > 0 || to.length > 0) {
        info(null, [ 'definitions', artifactName ], `No temporal WHERE clause added due to unbalanced @cds.valid.from/to`);
      }
    }
  }


  /**
   * Compute and return $combined for the given query.
   *
   * @param {CSN.Query} query
   * @returns {object}
   */
  function get$combined(query) {
    const sources = getSources(query);
    return sources;

    /**
     * Get the union of all elements from the from clause
     * - descend into unions, following the lead query
     * - merge all queries in case of joins
     * - follow subqueries
     *
     * @param {CSN.Query} query Query to check
     * @returns {object} Map of sources
     */
    function getSources(query) {
      if (query.SET) {
        if (query.SET.args[0].elements)
          return mergeElementsIntoMap(Object.create(null), query.SET.args[0].elements, query.SET.args[0].$location);

        return getSources(query.SET.args[0]);
      }
      else if (query.SELECT) {
        if (query.SELECT.from.args) {
          return walkArgs(query.SELECT.from.args);
        }
        else if (query.SELECT.from.ref) {
          const art = artifactRef(query.SELECT.from);
          return mergeElementsIntoMap(Object.create(null), art.elements, art.$location,
            query.SELECT.from.as || query.SELECT.from.ref[query.SELECT.from.ref.length - 1],
            query.SELECT.from.ref[query.SELECT.from.ref.length - 1] || query.SELECT.from.as );
        }
        else if (query.SELECT.from.SET || query.SELECT.from.SELECT) {
          return getSources(query.SELECT.from);
        }
      }

      function walkArgs(args) {
        let elements = Object.create(null);
        for (const arg of args) {
          if (arg.args) {
            elements = mergeElementMaps(elements, walkArgs(arg.args));
          }
          else if (arg.ref) {
            const art = artifactRef(arg);
            elements = mergeElementsIntoMap(elements, art.elements, art.$location, arg.as || arg.ref[arg.ref.length - 1], arg.ref[arg.ref.length - 1] || arg.as);
          }
          else if (arg.SELECT || arg.SET) {
            elements = mergeElementMaps(elements, getSources(arg));
          }
        }

        return elements;
      }

      return {};

      /**
       * Merge two maps of elements together
       *
       * @param {object} mapA Map a - will be returned
       * @param {object} mapB Map b - will not be returned
       * @returns {object} mapA
       */
      function mergeElementMaps(mapA, mapB) {
        for (const elementName in mapB) {
          if (!mapA[elementName])
            mapA[elementName] = [];

          mapB[elementName].forEach(e => mapA[elementName].push(e));
        }

        return mapA;
      }

      /**
       * Merge elements into an existing map
       *
       * @param {any} existingMap map to merge into - will be returned
       * @param {object} elements elements to merge into the map
       * @param {CSN.Location} $location $location of the elements - where they come from
       * @param {any} [parent] Name of the parent of the elements, alias before ref
       * @param {any} [error_parent] Parent name to use for error messages, ref before alias
       * @returns {object} existingMap
       */
      function mergeElementsIntoMap(existingMap, elements, $location, parent, error_parent) {
        for (const elementName in elements) {
          const element = elements[elementName];
          if (!existingMap[elementName])
            existingMap[elementName] = [];


          existingMap[elementName].push({
            element, name: elementName, source: $location, parent: getBaseName(parent), error_parent,
          });
        }

        return existingMap;
      }
    }
  }
  /**
   * Return the name part of the artifact name - no namespace etc.
   * @param {string|object} name Absolute name of the artifact
   */
  function getBaseName(name) {
    if (!name)
      return name;

    if (name.id)
      return name.id.substring( name.id.lastIndexOf('.')+1 );

    return name.substring( name.lastIndexOf('.')+1 )
  }

  /**
   * Get all elements tagged with @cds.valid.from/to from the union of all entities of the from-clause.
   *
   * @param {any} combined union of all entities of the from-clause
   * @returns {Array[]} Array where first field is array of elements with @cds.valid.from, second field is array of elements with @cds.valid.to.
   */
  function getFromToElements(combined) {
    const from = [];
    const to = [];
    for (const name in combined) {
      let elt = combined[name];
      if (!Array.isArray(elt))
        elt = [ elt ];
      elt.forEach((e) => {
        if (hasBoolAnnotation(e.element, '@cds.valid.from'))
          from.push(e);

        if (hasBoolAnnotation(e.element, '@cds.valid.to'))
          to.push(e);
      });
    }

    return [ from, to ];
  }

  /**
   * Check if any warnings were raised in earlier steps that need to be reclassified - i.e. as errors
   *
   * @param {CSN.Options} options
   */
  function reclassifyWarnings(options) {
    if (!options.messages)
      return;
    options.messages.forEach((message) => {
      // TODO: Switch/case doesn't seem right here
      switch (message.messageId) {
        case 'empty-entity':
        case 'check-proper-type-of':
          message.severity = 'Error';
          break;
      }
    });
  }

  /**
   * Associations that target a @cds.persistence.skip artifact must be removed
   * from the persistence model
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   * @param {string} prop
   * @param {CSN.Path} path
   */
  function ignoreAssociationToSkippedTarget(artifact, artifactName, prop, path) {
    if (isPersistedOnDatabase(artifact)) {
      // TODO: structure in CSN is artifact.query.[SELECT/SET].mixin
      if (artifact.query) {
        if (artifact.query.SELECT && artifact.query.SELECT.mixin)
          forEachGeneric(artifact.query.SELECT, 'mixin', ignore, path.concat([ 'query', 'SELECT' ]));

        else if (artifact.query.SET && artifact.query.SET.mixin)
          forEachGeneric(artifact.query.SET, 'mixin', ignore, path.concat([ 'query', 'SET' ]));
      }
      forEachMemberRecursively(artifact, ignore, [ 'definitions', artifactName ]);
    }
    function ignore(member, memberName, prop, path) {
      if (dialect === 'hana' && !member._ignore && member.target && isAssocOrComposition(member.type) && isUnreachableAssociationTarget(csn.definitions[member.target])) {
        info(null, path, `${ getFinalType(member.type).replace('cds.', '') } "${ memberName }" has been removed, as target "${ member.target }" is either 'abstract' or annotated with '@cds.persistence.skip/exists'`);
        member._ignore = true;
      }
    }
  }

  /**
   * @param {CSN.Artifact} art
   * @returns {boolean}
   */
  function isUnreachableAssociationTarget(art) {
    return !isPersistedOnDatabase(art) || hasBoolAnnotation(art, '@cds.persistence.exists');
  }

  // Perform transformations common to artifacts and members (in place)
  // Note that this should happen after implicit redirection and draft enabling, because
  // it would take away information required by those.
  function transformCommon(obj, objName, path) {
    // (060) Set length 36 for former type UUID (now String after 000)
    // setLengthForFormerUuid(obj);    // already done in step 000, so probably no longer needed here
    // setLengthForFormerUuid(obj.items); // already done in step 000, so probably no longer needed here
    // (070) Supply default length 5000 for strings if not specified
    // FIXME: Do we really want this?
    // addDefaultTypeFacets(obj);  // already done in step 000, so probably no longer needed here
    // addDefaultTypeFacets(obj.items);   // already done in step 000, so probably no longer needed here
    // (090) Compositions become associations
    /* Old if:
    if (obj.type && obj.type._artifact.name.absolute && obj.type._artifact.name.absolute === 'cds.Composition') {
        obj.type.path = [{id: obj.type.absolute}];
        setProp(obj.type, '_artifact', csn.definitions['cds.Association']);
        setProp(obj.type.path[0], '_artifact', csn.definitions['cds.Association']);
    }
    */

    // (100 b) Remove attribute 'localized'
    if (obj.localized)
      delete obj.localized;
    // (080) and (110) Ignore annotation declarations, actions, functions and events
    if (obj.kind === 'annotation' || obj.kind === 'action' || obj.kind === 'function' || obj.kind === 'event') {
      obj._ignore = true;
    }


    // (190 a) Replace enum symbols by their value (if found)
    replaceEnumSymbolsByValues(obj, path);
  }

  function walkCsnPath(path) {
    /** @type {object} */
    let obj = csn;
    for(let i = 0; i < path.length; i++){
      obj = obj[path[i]];
    }

    return obj;
  }

  // Change the names of those builtin types that have different names in HANA.
  // (do that directly in the csn where the builtin types are defined, so that
  // all users of the types benefit from it). Also add the type parameter 'length'
  // to 'UUID' (which becomes a string).
  // TODO: there is no benefit at all - it is fundamentally wrong
  function renamePrimitiveTypesAndUuid(val, node, key) {
    // assert key === 'type'
    const hanaNamesMap = createDict({
      'cds.DateTime': 'cds.UTCDateTime',
      'cds.Timestamp': 'cds.UTCTimestamp',
      'cds.Date': 'cds.LocalDate',
      'cds.Time': 'cds.LocalTime',
      'cds.UUID': 'cds.String',
    });
    node[key] = hanaNamesMap[val] || val;
    if (val === 'cds.UUID' && !node.length) {
      node.length = 36;
      setProp(node, '$renamed', 'cds.UUID');
    }
    // Length/Precision/Scale is done in addDefaultTypeFacets
  }

  // If 'obj' has final type 'cds.UUID' (renamed to String in 000), set its length to 36.
  // function setLengthForFormerUuid(obj) {
  //   if (!obj || !obj.type)
  //     return;
  //   if (obj.type === 'cds.UUID' && !obj.length) {
  //     obj.length = 36;
  //   }
  // }

  /**
  * Strip of leading $self of the ref
  * @param {object} col A column
  *
  * @returns {object}
  */
  function stripLeadingSelf(col) {
    if (col.ref && col.ref.length > 1 && col.ref[0] === '$self')
      col.ref = col.ref.slice(1);


    return col;
  }

  function isUnion(path){
    const subquery = path[path.length-1];
    const queryIndex = path[path.length-2]
    const args = path[path.length-3];
    const unionOperator = path[path.length-4];
    return path.length > 3 && (subquery === 'SET' || subquery === 'SELECT') && typeof queryIndex === 'number' && queryIndex >= 0 && args === 'args' && unionOperator === 'SET';
  }

  function transformEntityOrViewPass2(query, artifact, artName, path) {
    const { elements } = queryOrMain(query, artifact);
    let hasNonAssocElements = false;
    const isSelect = query && query.SELECT;
    let isProjection = !!artifact.projection;
    const columnMap = Object.create(null);
    let isSelectStar = false;
    if (isSelect) {
      if (!query.SELECT.columns) {
        isProjection = true;
      }
      else {
        query.SELECT.columns.forEach((col) => {
          if (col === '*') {
            isSelectStar = true;
          }
          else if (col.as) {
            if (!columnMap[col.as])
              columnMap[col.as] = col;
          }
          else if (col.ref) {
            if (!columnMap[col.ref[col.ref.length - 1]])
              columnMap[col.ref[col.ref.length - 1]] = col;
          }
          else if (col.func) {
            columnMap[col.func] = col;
          }
          else if (!columnMap[col]) {
            columnMap[col] = col;
          }
        });
      }
    }
    if (query && ( options.forHana || (options.toSql && options.toSql.dialect === 'hana'))) {
      // check all queries/subqueries for mixin publishing inside of unions -> forbidden in hdbcds
      if (query.SELECT && query.SELECT.mixin && path.indexOf('SET') !== -1) {
        for (const elementName in elements) {
          const element = elements[elementName];
          if (element.target) {
            let colLocation;
            for (let i = 0; i < query.SELECT.columns.length; i++) {
              const col = query.SELECT.columns[i];
              if (col.ref && col.ref.length === 1) {
                if (!colLocation && col.ref[0] === elementName)
                  colLocation = i;


                if (col.as === elementName)
                  colLocation = i;
              }
            }
            if (colLocation) {
              const matchingCol = query.SELECT.columns[colLocation];
              const possibleMixinName = matchingCol.ref[0];
              const isMixin = query.SELECT.mixin[possibleMixinName] !== undefined;
              if (element.target && isMixin)
                error(null, path.concat([ 'columns', colLocation ]),
                  `Element "${ elementName }" is a mixin association${ possibleMixinName !== elementName ? ` ("${ possibleMixinName }")` : '' } and can't be published in a UNION`);
            }
          }
        }
      }
    }

    // Second walk through the entity elements: Deal with associations (might also result in new elements)

    // Will be initialized JIT inside the elements-loop
    let $combined;

    for (const elemName in elements) {
      const elem = elements[elemName];
      if (isSelect) {
        if (!columnMap[elemName]) {
          // Prepend an alias if present
          let alias = (isProjection || isSelectStar) &&
              (query.SELECT.from.as || (query.SELECT.from.ref && implicitAs(query.SELECT.from.ref)));
          // In case of * and no explicit alias
          // find the source of the col by looking at $combined and prepend it
          if (isSelectStar && !alias && !isProjection) {
            if (!$combined)
              $combined = get$combined(query);


            const matchingCombined = $combined[elemName];
            // Internal errors - this should never happen!
            if (matchingCombined.length > 1) { // should already be caught by compiler
              throw new Error(`Ambiguous name - can't be resolved: ${ elemName }. Found in: ${ matchingCombined.map(o => o.parent) }`);
            }
            else if (matchingCombined.length === 0) { // no clue how this could happen? Invalid CSN?
              throw new Error(`No matching entry found in UNION of all elements for: ${ elemName }`);
            }
            alias = matchingCombined[0].parent;
          }
          if (alias)
            columnMap[elemName] = { ref: [ alias, elemName ] };
          else
            columnMap[elemName] = { ref: [ elemName ] };
        }

        // For associations - make sure that the foreign keys have the same "style"
        // If A.assoc => A.assoc_id, else if assoc => assoc_id or assoc as Assoc => Assoc_id
        if (elem.keys && !options.forHana.keepStructsAssocs) {
          const assoc_col = columnMap[elemName];
          if (assoc_col && assoc_col.ref) {
            elem.keys.forEach((key) => {
              const ref = cloneCsn(assoc_col.ref, options);
              ref[ref.length - 1] = [ ref[ref.length - 1] ].concat(key.as || key.ref).join(pathDelimiter);
              // Keep the $env of the parent column
              // so that we can still resolve the ref later on
              const result = {
                ref,
                $env: assoc_col.$env,
              };
              if (assoc_col.as)
                result.as = key.$generatedFieldName;


              if (assoc_col.key)
                result.key = true;


              const colName = result.as || ref[ref.length - 1];
              columnMap[colName] = result;
            });
          }
        }
        // Add flattened structured things preserving aliases and refs with/without table alias
        // If we add them when we get to them in "elements", we cannot know what table alias was used...
        if (isStructured(elem) && !options.forHana.keepStructsAssocs) {
          const col = columnMap[elemName];
          const originalName = col.ref[col.ref.length - 1];
          const flatElements = flattenStructuredElement(elem, originalName, [], path);
          const aliasedFlatElements = originalName !== elemName ? Object.keys(flattenStructuredElement(elem, elemName, [], path)) : [];

          Object.keys(flatElements).forEach((flatElemName, index ) => {
            const clone = cloneCsn(col, options);
            // For the ref, use the "original"
            if (clone.ref)
              clone.ref[clone.ref.length - 1] = flatElemName;

            // If the column was aliased, use the alias-prefix for the flattened element
            if (originalName !== elemName)
              clone.as = aliasedFlatElements[index];

            // Insert into map, giving precedence to the alias
            columnMap[clone.as || flatElemName] = clone;
          });
        }
      }
      // Views must have at least one element that is not an unmanaged assoc
      if (!elem.on && !elem._ignore)
        hasNonAssocElements = true;


      // (230 b) If we keep associations as they are (hdbcds naming convention), we cannot have managed associations
      // as view elements (their foreign keys cannot be addressed in the view)
      if (options.forHana.keepStructsAssocs &&
        query &&
        isAssocOrComposition(elem.type) &&
        !elem.on) {
        error(null, [ 'definitions', artName, 'elements', elemName ], `With "hdbcds" naming, managed association elements can't be used in a view`);
        continue;
      }

      // (180 b) Create MIXINs for association elements in projections or views (those that are not mixins by themselves)
      // CDXCORE-585: Allow mixin associations to be used and published in parallel
      if (query !== undefined && elem.target) {
        if(isUnion(path) && options.toHana){
          if(isBetaEnabled(options, 'ignoreAssocPublishingInUnion') && doA2J){
            if(elem.keys) {
              info(null, path, `Managed association "${elemName}", published in a UNION, will be ignored`)
            } else {
              info(null, path, `Association "${elemName}", published in a UNION, will be ignored`)
            }
            elem._ignore = true;
          }
          else {
            error(null, path, `Association "${elemName}" can't be published in a SAP HANA CDS UNION`)
          }
        } else {
          /* Old implementation:
        const isNotMixinByItself = !(elem.value && elem.value.path && elem.value.path.length == 1 && art.query && art.query.mixin && art.query.mixin[elem.value.path[0].id]);
        */
          const isNotMixinByItself = checkIsNotMixinByItself(query, columnMap, elem, elemName);
          const {mixinElement, mixinName } = getMixinAssocOfQueryIfPublished(query, elem, elemName);
          if (isNotMixinByItself || mixinElement !== undefined) {
            // If the mixin is only published and not used, only display the __ clone. Ignore the "original".
            if (mixinElement !== undefined && !usesMixinAssociation(query, elem, elemName)){
              mixinElement._ignore = true;
            }

            delete elem._typeIsExplicit;
            // Create an unused alias name for the MIXIN - use 3 _ to avoid collision with usings
            let mixinElemName = `___${ mixinName || elemName }`;
            while (elements[mixinElemName])
              mixinElemName = `_${ mixinElemName }`;

          // Copy the association element to the MIXIN clause under its alias name
          // (shallow copy is sufficient, just fix name and value)
            const mixinElem = Object.assign({}, elem);
          // Perform common transformations on the newly generated MIXIN element (won't be reached otherwise)
            transformCommon(mixinElem, mixinElemName);
          // TODO: Can we rely on query.SELECT.mixin to check for mixins?
          // Yes, we can - only SELECT can have mixin. But:
          // - UNION
          // - JOINS
          // - Subqueries
          // Are currently (and in the old transformer) not handled!
            if (query.SELECT && !query.SELECT.mixin)
              query.SELECT.mixin = Object.create(null);

          // Let the original association element use the newly generated MIXIN name as value and alias
            delete elem.viaAll;

          // Clone 'on'-condition, pre-pending '$projection' to paths where appropriate,
          // and fixing the association alias just created

            if (mixinElem.on) {
              mixinElem.on = cloneWithTransformations(mixinElem.on, {
                ref: (ref) => {
                // Clone the path, without any transformations
                  const clonedPath = cloneWithTransformations(ref, {});
                // Prepend '$projection' to the path, unless the first path step is the (mixin) element itself or starts with '$')
                  if (clonedPath[0] == elemName) {
                    clonedPath[0] = mixinElemName;
                  }
                  else if (!(clonedPath[0] && clonedPath[0].startsWith('$'))) {
                    const projectionId = '$projection';
                    clonedPath.unshift(projectionId);
                  }
                  return clonedPath;
                },
                func: (func) => {
                // Unfortunately, function names are disguised as paths, so we would prepend a '$projection'
                // above (no way to distinguish that in the callback for 'path' above). We can only pluck it
                // off again here ... sigh
                  if (func.ref && func.ref[0] && func.ref[0] === '$projection')
                    func.ref = func.ref.slice(1);

                  return func;
                },
              });
            }

            if (!mixinElem._ignore)
              columnMap[elemName] = { ref: [ mixinElemName ], as: elemName };

            if (query.SELECT) {
              query.SELECT.mixin[mixinElemName] = mixinElem;
            }
          }
        }
      }
    }

    if (query && !hasNonAssocElements) {
      // Complain if there are no elements other than unmanaged associations
      // Allow with plain
      error(null, [ 'definitions', artName ],
        'For SAP HANA CDS or SQL, a view or projection must have at least one element that is not an unmanaged association');
    }

    if (isSelect) {
      // Workaround for bugzilla 176495 FIXME FIXME FIXME: is this really still needed?
      // If a select item of a cdx view contains an expression, the result type cannot be computed
      // but must be explicitly specified. This is important for the OData channel, which doesn't
      // work if the type is missing (for HANA channel an explicit type is not required, as HANA CDS
      // can compute the result type).
      // Due to bug in HANA CDS, providing explicit type 'LargeString' or 'LargeBinary' causes a
      // diserver crash. Until a fix in HANA CDS is available, we allow to suppress the explicit
      // type in the HANA channel via an annotation.
      Object.keys(columnMap).forEach((value) => {
        const elem = elements[value];
        if (elem && elem['@cds.workaround.noExplicitTypeForHANA'])
          delete columnMap[value].cast;
      });

      query.SELECT.columns = Object.keys(elements).filter(elem => !elements[elem]._ignore).map(key => stripLeadingSelf(columnMap[key]));
      // If following an association, explicitly set the implicit alias
      // due to an issue with HANA
      for (let i = 0; i < query.SELECT.columns.length; i++) {
        const col = query.SELECT.columns[i];
        if (!col.as && col.ref && col.ref.length > 1) {
          const { links } = inspectRef(path.concat([ 'columns', i ]));
          if (links && links.slice(0, -1).some(({ art }) => isAssocOrComposition(art && art.type || '')))
            col.as = col.ref[col.ref.length - 1];
        }
      }
      delete query.SELECT.excluding;  // just to make the output of the new transformer the same as the old
    }
  }


  // If 'elem' has a default that is an enum constant, replace that by its value. Complain
  // if not found or not an enum type,
  function replaceEnumSymbolsByValues(elem, path) {
    // (190 a) Replace enum symbols by their value (if found)
    if (elem.default && elem.default['#']) {
      let Enum = elem.enum;
      if (!Enum && !isBuiltinType(elem.type)) {
        const typeDef = getCsnDef(elem.type);
        Enum = typeDef && typeDef.enum;
      }
      if (!Enum) {
        // Not an enum at all
        // Looks like it is always run?! But message says HANA CDS?!
        error(null, path, `Enum literal "#${ elem.default['#'] }" can only be used with an enum type in SAP HANA CDS`);
      }
      else {
        // Try to get the corresponding enum symbol from the element's type
        const enumSymbol = Enum[elem.default['#']];
        if (!enumSymbol) {
          error(null, path, `Enum literal "#${ elem.default['#'] }" not found in enumeration type`);
        }
        else if (enumSymbol.val !== undefined) { // `val` may be `null`
          // Replace default with enum value
          elem.default.val = enumSymbol.val;
          delete elem.default['#'];
        }
        else {
          // Enum symbol without explicit value - replace default by the symbol in string form
          elem.default.val = elem.default['#'];
          delete elem.default['#'];
        }
      }
    }
  }

  // If 'node' has an enum type, change node's type to be the enum's base type
  // and strip off the 'enum' property.
  function replaceEnumByBaseType(node) {
    if (node.items)
      replaceEnumByBaseType(node.items);

    // (190 b) Replace enum types by their final base type (must happen after 190 a)
    /* Old implementation:
    if (node && node._finalType && (node.enum || node._finalType.enum)) {
      node.type = node._finalType.type
      // node.type = node._finalType.type._artifact._finalType.type;
      if (node._finalType.length) {
        node.length = node._finalType.length;
      }
      setProp(node, '_finalType', node.type._artifact);
      delete node.enum;
    }
    */
    if (node && node.enum) {
      // toFinalBaseType(node);
      // addDefaultTypeFacets(node);
      delete node.enum;
    }
  }

  // If the association element 'elem' of 'art' is a backlink association, massage its ON-condition
  // (in place) so that it
  // - compares the generated foreign key fields of the corresponding forward
  //   association with their respective keys in 'art' (for managed forward associations)
  // - contains the corresponding forward association's ON-condition in "reversed" form,
  //   i.e. as seen from 'elem' (for unmanaged associations)
  // Otherwise, do nothing.
  function processBacklinkAssoc(elem, elemName, art, artName, pathToOn) {
    // Don't add braces if it is a single expression (ignoring superfluous braces)
    const multipleExprs = elem.on.filter(x => x !== '(' && x !== ')' ).length > 3;
    /**
     * Process the args
     *
     * @param {Array} xprArgs
     * @param {CSN.Path} path
     * @returns {Array} Array of parsed expression
     */
    function processExpressionArgs(xprArgs, path) {
      const result = [];
      let i = 0;
      while (i < xprArgs.length) {
        // Only token tripel `<path>, '=', <path>` are of interest here
        if (i < xprArgs.length - 2 && xprArgs[i + 1] === '=') {
          // Check if one side is $self and the other an association
          // (if so, replace all three tokens with the condition generated from the other side, in parentheses)
          if (isDollarSelfOrProjectionOperand(xprArgs[i]) && isAssociationOperand(xprArgs[i + 2], path.concat([ i + 2 ]))) {
            const assoc = inspectRef(path.concat([ i + 2 ])).art;
            if (multipleExprs)
              result.push('(');
            result.push(...transformDollarSelfComparison(xprArgs[i + 2],
              assoc,
              xprArgs[i + 2].ref[xprArgs[i + 2].ref.length - 1],
              elem, elemName, art, artName, path.concat([ i ])
            ));
            if (multipleExprs)
              result.push(')');
            i += 3;
          }
          else if (isDollarSelfOrProjectionOperand(xprArgs[i + 2]) && isAssociationOperand(xprArgs[i], path.concat([ i ]))) {
            const assoc = inspectRef(path.concat([ i ])).art;
            if (multipleExprs)
              result.push('(');
            result.push(...transformDollarSelfComparison(xprArgs[i], assoc, xprArgs[i].ref[xprArgs[i].ref.length - 1], elem, elemName, art, artName, path.concat([ i + 2 ])));
            if (multipleExprs)
              result.push(')');
            i += 3;
          }
          // Otherwise take one (!) token unchanged
          else {
            result.push(xprArgs[i]);
            i++;
          }
        }
        // Process subexpressions - but keep them as subexpressions
        else if(xprArgs[i].xpr){
          result.push({xpr: processExpressionArgs(xprArgs[i].xpr, path.concat([i, 'xpr']))});
          i++;
        }
        // Take all other tokens unchanged
        else {
          result.push(xprArgs[i]);
          i++;
        }
      }
      return result;
    }

    elem.on = processExpressionArgs(elem.on, pathToOn);

    // Return the condition to replace the comparison `<assocOp> = $self` in the ON-condition
    // of element <elem> of artifact 'art'. If there is anything to complain, use location <loc>
    function transformDollarSelfComparison(assocOp, assoc, assocName, elem, elemName, art, artifactName, path) {
      // Check: The forward link <assocOp> must point back to this artifact
      // FIXME: Unfortunately, we can currently only check this for non-views (because when a view selects
      // a backlink association element from an entity, the forward link will point to the entity,
      // not to the view).
      // FIXME: This also means that corresponding key fields should be in the select list etc ...
      if (!art.query && !art.projection && assoc.target && assoc.target != artifactName)
        error(null, path, `Only an association that points back to this artifact can be compared to "$self"`);


      // Check: The forward link <assocOp> must not contain '$self' in its own ON-condition
      if (assoc.on) {
        const containsDollarSelf = assoc.on.some(isDollarSelfOrProjectionOperand);

        if (containsDollarSelf)
          error(null, path, `An association that uses "$self" in its ON-condition can't be compared to "$self"`);
      }

      // Transform comparison of $self to managed association into AND-combined foreign key comparisons
      if (assoc.keys)
        return transformDollarSelfComparisonWithManagedAssoc(assocOp, assoc, assocName, elemName);

      // Transform comparison of $self to unmanaged association into "reversed" ON-condition
      else if (assoc.on)
        return transformDollarSelfComparisonWithUnmanagedAssoc(assocOp, assoc, assocName, elemName);

      throw new Error(`Expected either managed or unmanaged association in $self-comparison: ${ JSON.stringify(elem.on) }`);
    }

    // For a condition `<elemName>.<assoc> = $self` in the ON-condition of element <elemName>,
    // where <assoc> is a managed association, return a condition comparing the generated
    // foreign key elements <elemName>.<assoc>_<fkey1..n> of <assoc> to the corresponding
    // keys in this artifact.
    // For example, `ON elem.ass = $self` becomes `ON elem.ass_key1 = key1 AND elem.ass_key2 = key2`
    // (assuming that `ass` has the foreign keys `key1` and `key2`)
    function transformDollarSelfComparisonWithManagedAssoc(assocOp, assoc, originalAssocName, elemName) {
      const conditions = [];
      // if the element was structured then it was flattened => change of the delimiter from '.' to '_'
      // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
      const assocName = originalAssocName.replace(/\./g, pathDelimiter);
      elemName = elemName.replace(/\./g, pathDelimiter);

      assoc.keys.forEach((k) => {
        // Depending on naming conventions, the foreign key may two path steps (hdbcds) or be a single path step with a flattened name (plain, quoted)
        const keyName = k.as ? [k.as] : k.ref;
        const fKeyPath = options.forHana.keepStructsAssocs ? [ assocName, ...keyName ] : [ `${ assocName }${ pathDelimiter }${ keyName[0] }` ];
        // FIXME: _artifact to the args ???
        const a = [
          {
            ref: [ elemName, ...fKeyPath ],
          },
          { ref: k.ref },
        ];

        conditions.push([ a[0], '=', a[1] ]);
      });

      const result = conditions.reduce((prev, current) => {
        if (prev.length === 0)
          return [ ...current ];

        return [ ...prev, 'and', ...current ];
      }, []);

      return result;
    }

    // For a condition `<elemName>.<assoc> = $self` in the ON-condition of element <elemName>,
    // where <assoc> is an unmanaged association, return the ON-condition of <assoc> as it would
    // be written from the perspective of the artifact containing association <elemName>.
    // For example, `ON elem.ass = $self` becomes `ON a = elem.x AND b = elem.y`
    // (assuming that `ass` has the ON-condition `ON ass.a = x AND ass.b = y`)
    function transformDollarSelfComparisonWithUnmanagedAssoc(assocOp, assoc, originalAssocName, elemName) {
      // if the element was structured then it may have been flattened => change of the delimiter from '.' to '_'
      // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
      elemName = elemName.replace(/\./g, pathDelimiter);
      const assocName = originalAssocName.replace(/\./g, pathDelimiter);
      // clone the onCond for later use in the path transformation,
      // also assign the _artifact elements of the path elements to the copy
      const newOnCond = cloneWithTransformations(assoc.on, {
        ref: (value, node, resultNode) => {
          resultNode = cloneWithTransformations(value, {});
          return resultNode;
        },
      });
      // goes through the the newOnCond and transform all the 'path' elements
      forEachRef(newOnCond, (ref) => {
        if (ref[0] === assocName) // we are in the "path" from the forwarding assoc => need to remove the first part of the path
        {
          ref.shift();
        }
        else { // we are in the backlink assoc "path" => need to push at the beginning the association's id
          ref.unshift(elemName);
          // if there was a $self identifier in the forwarding association onCond
          // we do not need it any more, as we prepended in the previous step the back association's id
          if (ref[1] === '$self')
            ref.splice(1, 1);
        }
      });
      return newOnCond;
    }
  }

  // Replace (formerly) managed associations in GROUP BY and ORDER BY of 'view' by their foreign key fields.
  // FIXME: We should also complain about unmanaged assocs?
  // FIXME: We should also check for structured entries for 'keepStructsAssocs'
  function replaceAssociationsInGroupByOrderBy(view, viewName) {
    if (!view._ignore && view.query)
      forAllQueries(view.query, (q, p) => replaceAssocsInGroupOrder(q, p), [ 'definitions', viewName, 'query' ]);

    /**
     * @param {CSN.Query} inputQuery
     * @param {CSN.Path} path
     */
    function replaceAssocsInGroupOrder(inputQuery, path) {
      const query = inputQuery.SET || inputQuery.SELECT;

      if (query.groupBy) {
        const newGroupBy = [];
        for (let i = 0; i < query.groupBy.length; i++) {
          const groupByPath = path.concat([ 'groupBy', i ]);
          if (query.groupBy[i].ref) {
            const { art } = inspectRef(groupByPath);
            if (art && art.target) {
              if (art.keys) {
                // This is (or used to be before transformation) a managed assoc
                // (230 c) If we keep associations as they are (hdbcds naming convention), we can't have associations in GROUP BY
                if (options.forHana.keepStructsAssocs) {
                  error(null, groupByPath, `With "hdbcds" naming, managed association elements can't be used in the GROUP BY clause of a view`);
                  continue;
                }
                const pathPrefix = query.groupBy[i].ref.slice(0, -1);
                getForeignKeyRefs(art)
                  .map(fk => ({ ref: pathPrefix.concat(fk.ref) }))
                  .forEach(fk => newGroupBy.push(fk));
              }
              else {
                // This is an unmanaged association - these cannot be used in an order/group by
                // allow with plain?
                error(null, groupByPath, `Unmanaged association elements can't be used in the GROUP BY clause of a view`);
                continue;
              }
            }
            else {
              newGroupBy.push(query.groupBy[i]);
            }
          }
          else {
            newGroupBy.push(query.groupBy[i]);
          }
        }
        query.groupBy = newGroupBy;
      }

      if (query.orderBy) {
        const newOrderBy = [];
        for (let i = 0; i < query.orderBy.length; i++) {
          const orderByPath = path.concat([ 'orderBy', i ]);
          if (query.orderBy[i].ref) {
            const { art } = inspectRef(orderByPath);
            if (art && art.target) {
              if (art.keys) {
                // This is (or used to be before transformation) a managed assoc
                // (230 d) If we keep associations as they are (hdbcds naming convention), we can't have associations in ORDER BY
                if (options.forHana.keepStructsAssocs) {
                  error(null, orderByPath, `With "hdbcds" naming, managed association elements can't be used in the ORDER BY clause of a view`);
                  continue;
                }
                const pathPrefix = query.orderBy[i].ref.slice(0, -1);
                getForeignKeyRefs(art)
                  .map(fk => ({ ref: pathPrefix.concat(fk.ref) }))
                  .forEach(fk => newOrderBy.push(fk));
              }
              else {
                // This is an unmanaged association - these cannot be used in an order/group by
                // allow with plain?
                error(null, orderByPath, `Unmanaged association elements can't be used in the ORDER BY clause of a view`);
                continue;
              }
            }
            else {
              newOrderBy.push(query.orderBy[i]);
            }
          }
          else {
            newOrderBy.push(query.orderBy[i]);
          }
        }
        query.orderBy = newOrderBy;
      }
    }
    function getForeignKeyRefs(assoc) {
      return assoc.keys.map((fk) => {
        if (!fk.$generatedFieldName)
          throw new Error(`Expecting generated field name for foreign key: ${ JSON.stringify(fk) }`);

        return { ref: [ fk.$generatedFieldName ] };
      });
    }
  }

  // Collect all artifacts that are transitively reachable via compositions from 'artifact' into 'draftNodes'.
  // 'rootArtifact' is the root artifact where composition traversal started.
  // Check that no artifact other than the root node has '@odata.draft.enabled'
  function collectDraftNodesInto(artifact, artifactName, rootArtifact, draftNodes) {
    // Collect the artifact itself
    draftNodes[artifactName] = artifact;
    // Follow all composition targets in elements of 'artifact'
    for (const elemName in artifact.elements) {
      const elem = artifact.elements[elemName];
      if (elem.target && isComposition(elem.type)) {
        const draftNode = getCsnDef(elem.target);
        const draftNodeName = elem.target;
        // Sanity check
        if (!draftNode)
          throw new Error(`Expecting target to be resolved: ${ JSON.stringify(elem, null, 2) }`);

        // Ignore composition if not part of a service
        if (!isPartOfService(draftNodeName)) {
          warning(null, [ 'definitions', artifactName, 'elements', elemName ], `Target "${ draftNodeName }" of composition "${ artifactName }.${ elemName }" can't be a draft node because it is not part of a service`);
          continue;
        }
        // Barf if a draft node other than the root has @odata.draft.enabled itself
        if (draftNode != rootArtifact && hasBoolAnnotation(draftNode, '@odata.draft.enabled')) {
          error(null, [ 'definitions', artifactName, 'elements', elemName ], `Composition in draft-enabled entity can't lead to another entity with @odata.draft.enabled`);
          delete draftNodes[draftNodeName];
          continue;
        }
        // Recurse unless already known
        if (!hasBoolAnnotation(draftNode, '@odata.draft.enabled', false) && !draftNodes[draftNodeName])
          collectDraftNodesInto(draftNode, draftNodeName, rootArtifact, draftNodes);
      }
    }
  }

  /**
   * Generate all that is required in HANA CDS for draft enablement of 'artifact'.
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   * @param {string} draftRootName
   */
  function generateDraftForHana(artifact, artifactName, draftRootName) {
    // Sanity check
    if (!isPartOfService(artifactName))
      throw new Error(`Expecting artifact to be part of a service: ${ JSON.stringify(artifact) }`);


    // The name of the draft shadow entity we should generate
    const draftsArtifactName = `${ artifactName }${draftSuffix}`;

    // extract keys for UUID inspection
    const keys = [];
    forEachGeneric( artifact, 'elements', (elt) => {
      if (elt.key && elt.key === true && !elt.virtual)
        keys.push(elt);
    });

    // In contrast to EDM, the DB entity may have more than one technical keys but should have idealy exactly one key of type cds.UUID
    if (keys.length !== 1)
      warning(null, [ 'definitions', artifactName ], `"${ artifactName }": "@odata.draft.enabled" - Entity should have exactly one key element`);

    const uuidCount = keys.reduce((uuidCount, k) => ((k.type === 'cds.String' && k.$renamed === 'cds.UUID' && k.length === 36) ? ++uuidCount : uuidCount), 0);
    if (uuidCount === 0)
      warning(null, [ 'definitions', artifactName ], `"${ artifactName }": "@odata.draft.enabled" - Entity should have one key element of type "cds.UUID"`);


    const matchingService = getMatchingService(artifactName);
    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    const draftAdminDataProjectionName = `${ matchingService }.` + 'DraftAdministrativeData';
    let draftAdminDataProjection = csn.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(matchingService);

      redoProjections.push(() => {
        if(draftAdminDataProjection.query) {
          draftAdminDataProjection.projection = draftAdminDataProjection.query.SELECT;
          delete draftAdminDataProjection.query;
          if(draftAdminDataProjection.$syntax === 'projection') {
            delete draftAdminDataProjection.$syntax;
          }
        }
      });

      // Apply type renaming etc to the created projection
      transformCsn(draftAdminDataProjection, {
        type: (val, node, key) => {
          renamePrimitiveTypesAndUuid(val, node, key);
          addDefaultTypeFacets(node);
        },
        cast: (val) => {
          if (options.forHana.names === 'plain')
            toFinalBaseType(val);
          renamePrimitiveTypesAndUuid(val.type, val, 'type');
          addDefaultTypeFacets(val);
        },
      });

      // TODO: Investigate this - in old transformer, DraftUUID is marked as key in the columns
      // Why? How can we correctly emulate this behavior in the new transformer?
      if (!draftAdminDataProjection.query.SELECT.columns && draftAdminDataProjection.elements.DraftUUID) {
        draftAdminDataProjection.query.SELECT.columns = [
          {
            key: true,
            ref: [
              'DraftAdministrativeData',
              'DraftUUID',
            ],
          },
        ];
      }
    }

    // Barf if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind !== 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      // See draftAdminDataProjection which is defined in `csn.definitions`.
      const path = [ 'definitions', draftAdminDataProjectionName ];
      error(null, path, { name: draftAdminDataProjectionName },
        'Generated entity $(NAME) conflicts with existing artifact');
    }

    // Duplicate the artifact as a draft shadow entity
    if (csn.definitions[draftsArtifactName]) {
      const definingDraftRoot = csn.definitions[draftsArtifactName].$draftRoot;
      if (!definingDraftRoot)
        error(null, [ 'definitions', artifactName ], { name: draftsArtifactName },
          'Generated entity name $(NAME) conflicts with existing entity');

      else
        error(null, [ 'definitions', draftRootName ], { name: draftsArtifactName },
          `Entity $(NAME) already generated by draft root "${ definingDraftRoot }"`);

      return;
    }
    const draftsArtifact = {
      kind: 'entity',
      elements: Object.create(null),
    };

    // Add draft shadow entity to the csn
    csn.definitions[draftsArtifactName] = draftsArtifact;

    setProp(draftsArtifact, '$draftRoot', draftRootName);
    if(artifact.$location)
      setProp(draftsArtifact, '$location', artifact.$location);

    // Copy all elements
    for (const elemName in artifact.elements) {
      const origElem = artifact.elements[elemName];
      let elem = undefined;
      if(isDeprecatedEnabled(options, 'renderVirtualElements') && origElem.virtual)
        elem = copyAndAddElement(origElem, draftsArtifact, draftsArtifactName, elemName)[elemName];
      else if(!origElem.virtual)
        elem = copyAndAddElement(origElem, draftsArtifact, draftsArtifactName, elemName)[elemName];
      if(elem) {
        // Remove "virtual" - cap/issues 4956
        if(elem.virtual) {
          delete elem.virtual;
        }
        // explicitly set nullable if not key and not unmanaged association
        if (!elem.key && !elem.on)
          elem.notNull = false;
      }
    }

    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    const isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', false);
    // Use artifactName and not draftsArtifactName because otherwise we may point to the generated
    // entity in CSN and won't get a proper location (draftsArtifact has inherited all
    // elements from the original artifact).
    addElement(isActiveEntity, draftsArtifact, artifactName);

    // HasActiveEntity : Boolean default false
    const hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false);
    addElement(hasActiveEntity, draftsArtifact, artifactName);

    // HasDraftEntity : Boolean default false;
    const hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false);
    addElement(hasDraftEntity, draftsArtifact, artifactName);

    // DraftAdministrativeData : Association to one DraftAdministrativeData not null;
    const draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjectionName, true);
    draftAdministrativeData.DraftAdministrativeData.cardinality = {
      max: 1,
    };
    draftAdministrativeData.DraftAdministrativeData.notNull = true;
    addElement(draftAdministrativeData, draftsArtifact, artifactName);
    // Note that we may need to do the HANA transformation steps for managed associations
    // (foreign key field generation, generatedFieldName, creating ON-condition) by hand,
    // because the corresponding transformation steps have already been done on all artifacts
    // when we come here). Only for 'keepStructsAssocs' this is not required.
    /**
     * The given association has a key named DraftUUID
     *
     * @param {CSN.Association} association Assoc to check
     * @returns {object}
     */
    function getDraftUUIDKey(association) {
      if (association.keys) {
        const filtered = association.keys.filter(o => (o.ref && !o.as && o.ref.length === 1 && o.ref[0] === 'DraftUUID') || (o.as && o.as === 'DraftUUID'));
        if (filtered.length === 1)
          return filtered[0];

        else if (filtered.length > 1)
          return filtered.filter(o => o.as && o.as === 'DraftUUID');
      }

      return undefined;
    }

    function getNameForRef(obj) {
      if (obj.as)
        return obj.as;

      return obj.ref[obj.ref.length - 1];
    }

    const draftUUIDKey = getDraftUUIDKey(draftAdministrativeData.DraftAdministrativeData);
    if (!options.forHana.keepStructsAssocs && draftUUIDKey) {
      const path = [ 'definitions', draftsArtifactName, 'elements', 'DraftAdministrativeData', 'keys', 0 ];
      createForeignKeyElement(draftAdministrativeData.DraftAdministrativeData, 'DraftAdministrativeData', draftUUIDKey, draftsArtifact, draftsArtifactName, path);
      draftAdministrativeData.DraftAdministrativeData.on = createAssociationPathComparison('DraftAdministrativeData',
                                                                                           getNameForRef(draftUUIDKey),
                                                                                           '=',
                                                                                           `DraftAdministrativeData${ pathDelimiter }DraftUUID`);
      // The notNull has been transferred to the foreign key field and must be removed on the association
      delete draftAdministrativeData.DraftAdministrativeData.notNull;

      // The association is now unmanaged, i.e. actually it should no longer have foreign keys
      // at all. But the processing of backlink associations below expects to have them, so
      // we don't delete them (but mark them as implicit so that toCdl does not render them)
      // draftAdministrativeData.DraftAdministrativeData.implicitForeignKeys = true;
    }
  }

  // Redirect all association/composition targets in 'artifact' that point to targets in
  // the dictionary 'draftNodes' to their corresponding draft shadow artifacts.
  function redirectDraftTargets(artifact, draftNodes) {
    for (const elemName in artifact.elements) {
      const elem = artifact.elements[elemName];
      if (elem.target) {
        const targetArt = getCsnDef(elem.target);
        // Nothing to do if target is not a draft node
        if (!draftNodes[elem.target])
          continue;

        // Redirect the composition/association in this draft shadow entity to the target draft shadow entity
        // console.error(`Redirecting target of ${elemName} in ${artifact.name.absolute} to ${target.name.absolute + '_drafts'}`);
        const { shadowTarget, shadowTargetName } = getDraftShadowEntityFor(targetArt, elem.target);
        // Might not exist because of previous errors
        if (shadowTarget)
          elem.target = shadowTargetName;
          // FIXME: Strictly speaking, we would also need to replace the foreign keys' _artifact links,
          // but since their content is identical anyway, we simply omit that for now.
      }
    }

    // Returns the corresponding draft shadow artifact for draft node 'draftNode'.
    function getDraftShadowEntityFor(draftNode, draftNodeName) {
      // Sanity check
      if (!draftNodes[draftNodeName])
        throw new Error(`Not a draft node: ${ draftNodeName }`);

      return { shadowTarget: csn.definitions[`${ draftNodeName }${draftSuffix}`], shadowTargetName: `${ draftNodeName }${draftSuffix}` };
    }
  }

  /**
   * Check if the given element of the given element uses 'array of'.
   *
   * It checks the element itself and any types used or "subelements".
   *
   * @param {CSN.Artifact} artifact The artifact
   * @param {CSN.Element} element The element to check
   */
  function checkForArrayOf(artifact, artifactName, element, elementName) {
    /**
     * Show the error message for the given element name
     *
     * @param {string} eltName Name of the element
     */
    function show_error(eltName) {
      // Allow with plain
      error(null, [ 'definitions', artifactName, 'elements', eltName ],
        'Array types are not allowed as table types');
    }

    /**
     * Recursively check the if the given element contains array of
     * and is really going to the database (no @cds.persistence.skip/exists: true)
     * @param {CSN.Element} e Element to check
     * @param {string} eName Element name
     * @param {string} [current_path] Current path for better error messages
     * @param {boolean} [skip_name=false]
     */
    function check(e, eName, current_path, skip_name = false) {
      // Only append element names to the path, skip names for typeof, since those take the following route:
      // a: x; b: typeof a; b -> a -> x. We only want to log b -> x
      if (eName && !skip_name) {
        if (!current_path)
          current_path = eName;
        else
          current_path += `.${ eName }`;
      }

      // E is undefined -> return. Should not happen, just in case.
      if (!e) {
        return;
      }
      // Element has items -> This means it is an array of, show error and return.
      else if (e.items) {
        show_error(current_path);
      }
      // Element has elements -> Check each sub-element.
      else if (e.elements) {
        for (const innerElement of Object.keys(e.elements))
          check(e.elements[innerElement], innerElement, current_path);
      }
      // Element has a type -> Check if the type is/contains an array
      else if (e.type) {
        // Don't check built-ins
        if (isBuiltinType(e.type))
          return;

        check(csn.definitions[e.type], e.type, current_path);
      }
      else {
        return;
      }
    }
    // Start the recursive checking (if table is really about to be created)
    // FIXME: same expression as in checkElements => utility function?
    const createTable = !(artifact.abstract || (artifact['@cds.persistence.skip'] && artifact['@cds.persistence.skip'] !== null && artifact['@cds.persistence.skip'] !== false) ||
      (artifact['@cds.persistence.exists'] && artifact['@cds.persistence.exists'] !== null && artifact['@cds.persistence.exists'] !== false));

    if (createTable)
      check(element, elementName);
  }

  /**
   * @todo: XSN - Implementation most likely too naive, can we rely on query.SELECT.mixin?
   *
   * @param {CSN.Query} query
   * @param {object} columnMap
   * @param {CSN.Artifact} columnMap
   * @param {string} elementName
   */
  function checkIsNotMixinByItself(query, columnMap, element, elementName) {
    if (query && query.SELECT && query.SELECT.mixin) {
      const col = columnMap[elementName];

      const realName = col.ref[col.ref.length - 1];
      // If the element is not part of the mixin => True
      return query.SELECT.mixin[realName] == undefined;
    }
    // the artifact does not define any mixins, the element cannot be a mixin
    return true;
  }

  function insideColumns(path) {
    return path.length >= 3 && path[path.length - 3] === 'SELECT' && path[path.length - 2] === 'columns';
  }

  /**
   * Check the given query for:
   * - Associations-traversal over skipped/abstract things
   *
   * Currently checked:
   * - "columns" for something like toF.id, where F is skipped. But publishing toF is fine, will be ignored later on
   * - "from" for something like "select from E.toF" where E, F or E AND F are no-db.
   *
   * @param {CSN.Query} query Query to check
   * @param {CSN.Path} path Path to the current query
   */
  function checkQueryForNoDBArtifacts(query, path) {
    const generalQueryProperties = [ 'from', 'columns' ];
    for (const prop of generalQueryProperties) {
      const queryPart = query[prop];
      if (Array.isArray(queryPart)) {
        for (let i = 0; i < queryPart.length; i++) {
          const part = queryPart[i];
          checkRef(part, path.concat([ prop, i ]), prop === 'from');
        }
      }
      else if (typeof queryPart === 'object') {
        checkRef(queryPart, path.concat([ prop ]), prop === 'from');
      }
    }

    function checkRef(obj, path, inFrom) {
      if (!(obj && obj.ref))
        return;


      const { links, scope } = inspectRef(path);
      if (!links || scope === 'alias')
        return;

      // Don't check the last element - to allow association publishing in columns
      for (let i = 0; i < (inFrom ? links.length : links.length - 1); i++) {
        const link = links[i];
        if (!link)
          continue;

        const { art } = link;
        if (!art)
          continue;

        const endArtifact = art.target ? csn.definitions[art.target] : art;
        const name = art.target ? art.target : obj.ref[i];
        if (!isPersistedOnDatabase(endArtifact))
          error(null, path, `"${ path[1] }": "${ name }" in path step "${ obj.ref[i] }" of "${ obj.ref.join('.') }" is either 'abstract' or '@cds.persistence.skip'`);
      }
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function checkTypeParameters(artifact, artifactName) {
    forEachMemberRecursively(artifact, (member, memberName, prop, path) => {
      // Check type parameters (length, precision, scale ...)
      if (!member._ignore && member.type)
        _check(member, memberName, csn, path);

      if (!member._ignore && member.items && member.items.type)
        _check(member.items, memberName, csn, path.concat([ 'items' ]));
    }, [ 'definitions', artifactName ]);

    // Check that required actual parameters on 'node.type' are set, that their values are in the correct range etc.
    function _check(node, nodeName, model, path) {
      if (node.type) {
        const absolute = node.type;
        const parameters = node.parameters || [];
        // :FIXME: Is this dead code? node.parameters is always undefined...
        // forHana tested against the parameters of the type definition which is not available in CSN
        for (const name in parameters) {
          const param = parameters[name];
          if (!node[param] && absolute !== 'cds.hana.ST_POINT' && absolute !== 'cds.hana.ST_GEOMETRY')
            error(null, path, `Actual value for type parameter '${ param }' missing in reference to type '${ absolute }'`);
        }
        switch (absolute) {
          case 'cds.String':
          case 'cds.Binary':
          case 'cds.hana.VARCHAR': {
            checkTypeParamValue(node, 'length', 'positiveInteger', { min: 1, max: 5000 }, path);
            break;
          }
          case 'cds.Decimal': {
            // Don't check with "plain"?
            if (node.precision || node.scale) {
              checkTypeParamValue(node, 'precision', 'positiveInteger', { max: 38 }, path);
              checkTypeParamValue(node, 'scale', 'positiveInteger', { max: node.precision }, path);
            }
            break;
          }

          case 'cds.hana.BINARY':
          case 'cds.hana.NCHAR':
          case 'cds.hana.CHAR': {
            checkTypeParamValue(node, 'length', 'positiveInteger', { min: 1, max: 2000 }, path);
            break;
          }
          case 'cds.hana.ST_POINT':
          case 'cds.hana.ST_GEOMETRY': {
            checkTypeParamValue(node, 'srid', 'positiveInteger', { max: Number.MAX_SAFE_INTEGER }, path);
            break;
          }
        }
      }

      // Check that the value of the type property `paramName` (e.g. length, precision, scale ...) is of `expectedType`
      // (which can currently only be 'positiveInteger') and (optional) the value is in a given range
      function checkTypeParamValue(node, paramName, expectedType, range = undefined, path) {
        const paramValue = node[paramName];
        if (paramValue == undefined) {
          if(options.toSql || artifact.query || !["cds.Binary","cds.hana.BINARY", 'cds.hana.NCHAR','cds.hana.CHAR'].includes(node.type)) {
            return true;
          } else {
            return error(null, path, `Actual value for type parameter '${ paramName }' missing in reference to type '${ node.type }'`);
          }
        }
        switch (expectedType) {
          case 'positiveInteger':
            if (!(Number.isInteger(paramValue) && paramValue >= 0)) {
              error(null, path, `Actual parameter '${ paramName }' for '${ node.type }' must be positive integer`);
              return false;
            }
            break;
          default:
            throw 'Unknown "expectedType"';
        }
        if (range) {
          if (isMaxParameterLengthRestricted(node.type) && range.max && paramValue > range.max) {
            error(null, path, `Actual parameter '${ paramName }' for '${ node.type }' is larger than allowed (max: ${ range.max })`);
            return false;
          }
          if (range.min && paramValue < range.min) {
            error(null, path, `Actual parameter '${ paramName }' for '${ node.type }' is smaller than allowed (min: ${ range.min })`);
            return false;
          }
        }
        return true;
      }
    }
  }

  /**
  * Check if the maximum length of the value of the given type is restricted.
  *
  * @param {string} type
  * @returns {boolean}
  */
  function isMaxParameterLengthRestricted(type) {
    return !(options.toSql && type === 'cds.String' && (options.toSql.dialect === 'sqlite' || options.toSql.dialect === 'plain'));
  }

  /**
   * Check if the given artifact is part of a service.
   *
   * @param {string} artifactName Absolute name of the artifact
   * @returns {boolean}
   */
  function isPartOfService(artifactName) {
    for (const serviceName of allServices) {
      if (artifactName.startsWith(`${ serviceName }.`))
        return true;
    }

    return false;
  }

  /**
   * Get the service name containing the artifact.
   *
   * @param {string} artifactName Absolute name of the artifact
   * @returns {boolean|string} Name of the service or false if no match is found.
   */
  function getMatchingService(artifactName) {
    const matches = [];
    for (const serviceName of allServices) {
      if (artifactName.startsWith(`${ serviceName }.`))
        matches.push(serviceName);
    }
    if (matches.length === 0)
      return false;
    else
      return matches.sort((a, b) => a.length - b.length)[0];
  }

  /**
   * Get not just the leafs, but all the branches of a structured element
   *
   * @param {object} element Structured element
   * @param {string} elementName Name of the structured element
   * @returns {object} Returns a dictionary, where the key is the flat name of the branch and the value is an array of element-steps.
   */
  function getBranches(element, elementName){
    const branches = {};
    const subbranchNames = [];
    const subbranchElements = [];
    walkElements(element, elementName);
    function walkElements(e, name){
      if(isBuiltinType(e)){
        branches[subbranchNames.concat(name).join(pathDelimiter)] = subbranchElements.concat(e);
      } else {
        const eType = effectiveType(e)
        const subelements = e.elements || eType.elements;
        if(subelements){
          subbranchElements.push(e);
          subbranchNames.push(name);
          for(let [subelementName, subelement] of Object.entries(subelements)){
            walkElements(subelement, subelementName);
          }
          subbranchNames.pop();
          subbranchElements.pop();
        } else {
          branches[subbranchNames.concat(name).join(pathDelimiter)] = subbranchElements.concat(e);
        }

      }
    }
    return branches;
  }

  /**
   * Flatten structures
   *
   * @param {CSN.Artifact} art Artifact
   * @param {string} artName Artifact Name
   */
  function flattenStructuredElements(art, artName) {
    if ((art.kind === 'entity' || art.kind === 'view') && !options.forHana.keepStructsAssocs) {
      forAllElements(art, artName, (parent, elements, pathToElements) => {
        const elementsArray = [];
        for (const elemName in elements) {
          const pathToElement = pathToElements.concat([elemName])
          const elem = parent.elements[elemName];
          elementsArray.push([elemName, elem]);
          if (isStructured(elem)) {
            // Ignore the structured element, replace it by its flattened form
            // TODO: use $ignore - _ is for links
            elem._ignore = true;

            const branches = getBranches(elem, elemName);
            const flatElems = flattenStructuredElement(elem, elemName, [], pathToElement);

            for (const flatElemName in flatElems) {
              if (parent.elements[flatElemName])
                error(null, pathToElement, `"${ artName }.${ elemName }": Flattened struct element name conflicts with existing element: "${ flatElemName }"`);

              const flatElement = flatElems[flatElemName];

              // Check if we have a valid notNull chain
              const branch = branches[flatElemName];
              if(flatElement.notNull !== false && !branch.some(s => !s.notNull)){
                flatElement.notNull = true;
              }

              if(flatElement.type && isAssocOrComposition(flatElement.type) && flatElement.on){
                // Make refs resolvable by fixing the first ref step
                for (let i = 0; i < flatElement.on.length; i++) {
                  const onPart = flatElement.on[i];
                  if (onPart.ref) {
                    const firstRef = flatElement.on[i].ref[0];

                  /*
                    when element is defined in the current name resolution scope, like
                      entity E {
                        key x: Integer;
                            s : {
                            y : Integer;
                            a3 : association to E on a3.x = y;
                            }
                      }
                      We need to replace y with s_y and a3 with s_a3 - we must take care to not escape our local scope
                  */
                    const prefix = flatElement._flatElementNameWithDots.split('.').slice(0,-1).join(pathDelimiter);
                    const possibleFlatName = prefix + pathDelimiter + firstRef;

                    if (flatElems[possibleFlatName])
                      flatElement.on[i].ref[0] = possibleFlatName;
                  }
                }
              }
              elementsArray.push([flatElemName, flatElement]);
              // Still add them - otherwise we might not detect collisions between generated elements.
              parent.elements[flatElemName] = flatElement;
            }
          }
        }
          //  Don't fake consistency of the model by adding empty elements {}
        if(elementsArray.length === 0)
          return;

        parent.elements = elementsArray.reduce((previous, [name, element]) => {
          previous[name] = element;
          return previous;
        }, Object.create(null));
      });
    }
  }

  /**
   * Flatten and create the foreign key elements of managed associaitons
   *
   * @param {CSN.Artifact} art
   * @param {string} artName
   */
  function handleManagedAssociationFKs(art, artName) {
    if ((art.kind === 'entity' || art.kind === 'view') && !options.forHana.keepStructsAssocs) {
      forAllElements(art, artName, (parent, elements, pathToElements) => {
        if(artName.startsWith('localized.') && pathToElements.length > 3) {
          // In subqueries, the elements of localized views are missing all the important bits and pieces...
          fixBorkedElementsOfLocalized(elements, pathToElements);
        }
        forEachGeneric(parent, 'elements', (element, elemName) => {
          if (isManagedAssociationElement(element)) {
            if (element.keys) {
              // replace foreign keys that are managed associations by their respective foreign keys
              flattenFKs(element, elemName, [ ...pathToElements, elemName ]);
            }
          }
        });
      })
    }
  }


  /**
   * Flattens all foreign keys
   *
   * Structures will be resolved to individual elements with scalar types
   *
   * Associations will be replaced by their respective foreign keys
   *
   * If a structure contains an assoc, this will also be resolved and vice versa
   *
   * @param {*} assoc
   * @param {*} assocName
   * @param {*} path
   */
  function flattenFKs(assoc, assocName, path) {
    let finished = false;
    while(!finished) {
      const newKeys = [];
      finished = processKeys(assoc, assocName, path, newKeys);
      assoc.keys = newKeys;
    }

    function processKeys(assoc, assocName, path, collector) {
      let finished = true;
      for (let i = 0; i < assoc.keys.length; i++) {
        const pathToKey = path.concat([ 'keys', i ]);
        const { art } = inspectRef(pathToKey);
        const { ref } = assoc.keys[i];
        if (isStructured(art)) {
          finished = false;
          // Mark this element to filter it later - not needed after expansion
          setProp(assoc.keys[i], '$toDelete', true);
          const flat = flattenStructuredElement(art, ref[ref.length - 1], [], pathToKey);
          Object.keys(flat).forEach((flatElemName) => {
            const key = assoc.keys[i];
            const clone = cloneCsn(assoc.keys[i], options);
            if (clone.as) {
              const lastRef = clone.ref[clone.ref.length - 1];
              // Cut off the last ref part from the beginning of the flat name
              const flatBaseName = flatElemName.slice(lastRef.length);
              // Join it to the existing table alias
              clone.as += flatBaseName;
              // do not loose the $ref for nested keys
              if(key.$ref){
                let aliasedLeaf = key.$ref[key.$ref.length - 1 ];
                aliasedLeaf += flatBaseName;
                setProp(clone, '$ref', key.$ref.slice(0, key.$ref.length - 1).concat(aliasedLeaf));
              }
            }
            if (clone.ref) {
              clone.ref[clone.ref.length - 1] = flatElemName;
              // Now we need to properly flatten the whole ref
              clone.ref = flattenStructStepsInRef(clone.ref, pathToKey);
            }
            if (!clone.as) {
              clone.as = flatElemName;
              // TODO: can we use $inferred? Does it have other weird side-effects?
              setProp(clone, '$inferredAlias', true);
            }
            // Directly work on csn.definitions - this way the changes take effect in csnRefs/inspectRef immediately
            // Add the newly generated foreign keys to the end - they will be picked up later on
            // Recursive solutions run into call stack issues
            collector.push(clone);
          });
        }
        else if (art.target) {
          finished = false;
          // Mark this element to filter it later - not needed after expansion
          setProp(assoc.keys[i], '$toDelete', true);
          // Directly work on csn.definitions - this way the changes take effect in csnRefs/inspectRef immediately
          // Add the newly generated foreign keys to the end - they will be picked up later on
          // Recursive solutions run into call stack issues
          art.keys.forEach(key => collector.push(cloneAndExtendRef(key, assoc.keys[i], ref)));
        }
        else if (assoc.keys[i].ref && !assoc.keys[i].as) {
          setProp(assoc.keys[i], '$inferredAlias', true);
          assoc.keys[i].as = assoc.keys[i].ref[assoc.keys[i].ref.length - 1];
          collector.push(assoc.keys[i]);
        } else {
          collector.push(assoc.keys[i]);
        }
      }
      return finished;
    }
    assoc.keys = assoc.keys.filter(o => !o.$toDelete);
  }

  function cloneAndExtendRef(key, base, ref) {
    const clone = cloneCsn(base, options);
    if (key.ref) {
      // We build a ref that contains the aliased fk - that element will be created later on, so this ref is not resolvable yet
      // Therefore we keep it as $ref - ref is the non-aliased, resolvable "clone"
      // Later on, after we know that these foreign key elements are created, we replace ref with this $ref
      let $ref;
      if(base.$ref){
        // if a base $ref is provided, use it to correctly resolve association chains
        const refChain =  [base.$ref[base.$ref.length - 1]].concat(key.as || key.ref);
        $ref = base.$ref.slice(0, base.$ref.length - 1).concat(refChain)
      } else {
        $ref = base.ref.concat( key.as || key.ref); // Keep along the aliases
      }
      setProp(clone, '$ref', $ref);
      clone.ref = clone.ref.concat(key.ref);
    }

    if (!clone.as && clone.ref && clone.ref.length > 0) {
      clone.as = ref[ref.length - 1] + pathDelimiter + (key.as || key.ref.join(pathDelimiter));
      // TODO: can we use $inferred? Does it have other weird side-effects?
      setProp(clone, '$inferredAlias', true);
    }
    else {
      clone.as += pathDelimiter + (key.as || key.ref.join(pathDelimiter));
    }

    return clone;
  }

  /**
   * Flatten technical configuration stuff
   *
   * @param {CSN.Artifact} art
   * @param {string} artName Artifact Name
   */
  function flattenIndexes(art, artName) {
    // Flatten structs in indexes (unless explicitly asked to keep structs)
    const tc = art.technicalConfig;
    if ((art.kind === 'entity' || art.kind === 'view') && !options.forHana.keepStructsAssocs) {
      if (tc && tc[dialect]) {
        // Secondary and fulltext indexes
        for (const name in tc[dialect].indexes) {
          const index = tc[dialect].indexes[name];
          if (Array.isArray(index)) {
            const flattenedIndex = [];
            const isFulltextIndex = (index[0] === 'fulltext');
            index.forEach((val, idx) => {
              if (typeof val === 'object' && val.ref) {
                // Replace a reference by references to it's elements, if it is structured
                const path = [ 'definitions', artName, 'technicalConfig', dialect, 'indexes', name, idx ];
                const { art } = inspectRef(path);
                if (!art) {
                  // A reference that has no artifact (e.g. the reference to the index name itself). Just copy it over
                  flattenedIndex.push(val);
                }
                else if (art.elements) {
                  // The reference is structured
                  if (isFulltextIndex)
                    error(null, path, `"${ artName }": A fulltext index can't be defined on a structured element`);
                  // First, compute the name from the path, e.g ['s', 's1', 's2' ] will result in 'S_s1_s2' ...
                  const refPath = flattenStructStepsInRef(val.ref, path);
                  // ... and take this as the prefix for all elements
                  const flattenedElems = flattenStructuredElement(art, refPath, [], ['definitions', artName, 'elements']);
                  Object.keys(flattenedElems).forEach((elem, i, elems) => {
                    // if it's not the first entry, add a ',' ...
                    if (i)
                      flattenedIndex.push(',');
                    // ... then add the flattend element name as a single ref
                    flattenedIndex.push({ ref: [ elem ] });
                    // ... then check if we have to propagate a 'asc'/'desc', omitting the last, which will be copied automatically
                    if ((idx + 1) < index.length && (index[idx + 1] === 'asc' || index[idx + 1] === 'desc') && i < elems.length - 1)
                      flattenedIndex.push(index[idx + 1]);
                  });
                }
                else {
                  // The reference is not structured, so just replace it by a ref to the combined prefix path
                  const refPath = flattenStructStepsInRef(val.ref, path);
                  flattenedIndex.push({ ref: refPath });
                }
              }
              else // it's just some token like 'index', '(' etc. so we copy it over
              {
                flattenedIndex.push(val);
              }
            });
            // Replace index by the flattened one
            tc[dialect].indexes[name] = flattenedIndex;
          }
        }
      }
    }
  }

  /**
   * Loop over all elements and for all unmanaged associations translate
   * <assoc base>.<managed assoc>.<fk> to <assoc base>.<managed assoc>_<fk>
   *
   * Or in other words: Allow using the foreign keys of managed associations in on-conditions
   *
   * @param {CSN.Artifact} artifact Artifact to check
   * @param {string} artifactName Name of the artifact
   */
  function handleManagedAssocStepsInOnCondition(artifact, artifactName) {
    for (const elemName in artifact.elements) {
      const elem = artifact.elements[elemName];
      if (!options.forHana.keepStructsAssocs) {
        // The association is an unmanaged on
        if (!elem.keys && elem.target && elem.on) {
          forEachRef(elem.on, (ref, refOwner, path) => {
            // [<assoc base>.]<managed assoc>.<field>
            if (ref.length > 1) {
              const { links } = inspectRef(path);
              if (links) {
                // eslint-disable-next-line for-direction
                for (let i = links.length - 1; i >= 0; i--) {
                  const link = links[i];
                  // We found the latest managed assoc path step
                  if (link.art && link.art.target && link.art.keys) {
                    // Doesn't work when ref-where or similar is used
                    if (!ref.slice(i).some(refElement => typeof refElement !== 'string')) {
                      // We join the managed assoc with everything following it
                      const sourceElementName = ref.slice(i).join(pathDelimiter);
                      const source = findSource(links, i - 1) || artifact;
                      // allow specifying managed assoc on the source side
                      const fks = link.art.keys.filter(fk => ref[i] + pathDelimiter + fk.ref[0] ===  sourceElementName);

                      if(fks && fks.length >= 1){
                        const fk = fks[0];
                        if(source && source.elements[fk.$generatedFieldName])
                          refOwner.ref = [ ...ref.slice(0, i), fk.$generatedFieldName ];
                      }
                    }
                  }
                }
              }
            }
          }, [ 'definitions', artifactName, 'elements', elemName, 'on' ]);
        }
      }
    }

    /**
     * Find out where the managed association is
     *
     * @param {Array} links
     * @param {Number} startIndex
     * @returns {Object| undefined} CSN definition of the source of the managed association
     *
     */
    function findSource(links, startIndex) {
      for (let i = startIndex; i >= 0; i--) {
        const link = links[i];
        // We found the latest assoc step - now check where that points to
        if (link.art && link.art.target)
          return csn.definitions[link.art.target];
      }

      return undefined;
    }
  }

  /**
   * Create the foreign key elements for a managed association and build the on-condition
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   * @param {Object} elem The association to process
   * @param {string} elemName
   * @returns {void}
   */
  function transformManagedAssociation(artifact, artifactName, elem, elemName) {
    // No need to run over this - we already did, possibly because it was referenced in the ON-Condition
    // of another association - see a few lines lower
    if (elem.$fksgenerated)
      return;
    // Generate foreign key elements for managed associations, and assemble an ON-condition with them
    const onCondParts = [];
    let join_with_and = false;

    for (let i = 0; i < elem.keys.length; i++) {
      const foreignKey = elem.keys[i];

      // Assemble left hand side of 'assoc.key = fkey'
      const assocKeyArg = {
        ref: [
          elemName,
        ].concat(foreignKey.ref),
      };

      const fKeyArg = {
        ref: [
          foreignKey.$generatedFieldName,
        ],
      };

      if (join_with_and) { // more than one FK
        onCondParts.push('and');
      }

      onCondParts.push(
        assocKeyArg
      );
      onCondParts.push('=');
      onCondParts.push(fKeyArg);

      if (!join_with_and)
        join_with_and = true;
    }

    elem.on = onCondParts;

    // If the managed association has a 'key' property => remove it as unmanaged assocs cannot be keys
    // TODO: Are there other modifiers (like 'key') that are valid for managed, but not valid for unmanaged assocs?
    if (elem.key)
      delete elem.key;


    // If the managed association has a 'not null' property => remove it
    if (elem.notNull)
      delete elem.notNull;


    // The association is now unmanaged, i.e. actually it should no longer have foreign keys
    // at all. But the processing of backlink associations below expects to have them, so
    // we don't delete them (but mark them as implicit so that toCdl does not render them)
    /* Skip for now - forHana adds this to elements, but it is not part of the resulting CSN
        forHanaNew -> Somehow ends up in the CSN?!
        elem.implicitForeignKeys = true;
    */
    // Remember that we already processed this
    setProp(elem, '$fksgenerated', true);
  }
}


module.exports = {
  transformForHanaWithCsn,
};
